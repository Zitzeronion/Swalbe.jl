var documenterSearchIndex = {"docs":
[{"location":"functions/#Internal-Functions","page":"Functions","title":"Internal Functions","text":"","category":"section"},{"location":"functions/#Swalbe.equilibrium!-NTuple{4, Any}","page":"Functions","title":"Swalbe.equilibrium!","text":"equilibrium!(feq, height, velocity, gravity)\n\nCalculation of the equilibrium distribution feq for the shallow water lattice Boltzmann method.\n\nArguments\n\nfeq :: Array{<:Number,3}: Equilibrium distribution function, to be calculated\nheight :: Array{<:Number,2}: The height field h(mathbfxt)\nvelocity :: Array{<:Number,2}: x-component of the macroscopic velocity\ngravity <: Number: Strength of the gravitational acceleration in lattice units\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> feq = zeros(10,3); ρ = ones(10); u = fill(0.1,10);\n\njulia> Swalbe.equilibrium!(feq, ρ, u, 0.1) # Supply dummy u^2 as well.\n\njulia> feq[:,1]\n10-element Vector{Float64}:\n 0.94\n 0.94\n 0.94\n 0.94\n 0.94\n 0.94\n 0.94\n 0.94\n 0.94\n 0.94\n\njulia> @test all(feq[:,1] .≈ 1 - 0.1/2 - 0.01)\nTest Passed\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.equilibrium!-NTuple{6, Any}","page":"Functions","title":"Swalbe.equilibrium!","text":"equilibrium!(feq, height,velocityx, velocityy, vsquare, gravity)\n\nCalculation of the equilibrium distribution feq for the shallow water lattice Boltzmann method.\n\nArguments\n\nfeq :: Array{<:Number,3}: Equilibrium distribution function, to be calculated\nheight :: Array{<:Number,2}: The height field h(mathbfxt)\nvelocityx :: Array{<:Number,2}: x-component of the macroscopic velocity\nvelocityy :: Array{<:Number,2}: y-component of the macroscopic velocity\nvsquare :: Array{<:Number,2}: Dummy array that is preallocated to be filled with the square of the velocity vector\ngravity <: Number: Strength of the gravitational acceleration in lattice units\n\nMathematics\n\nThe detailed motivation and derivation can be found in the article of Salmon. Similar to the standard Navier-Stokes approximating lattice Boltzmann methods the equilibrium distribution feq is an expansion to second order in velocity u. If you want it is an slow mode part of the shallow water theory and thus the equilibrium is given as\n\nf_i^texteq = h bigg(1 - frac56g h - frac23u^2bigg)quad i=0 newline    f_i^texteq = w_i h bigg(g h + 3 mathbfc_icdotmathbfu + frac92(mathbfc_icdotmathbfu)^2) + frac32u^2bigg)quad else\n\nwhere g is the gravitational acceleration (in lattice units) and w_i mathbfc_i are the weights and lattice velocities.\n\nIt has been shown that it is possible to get rid of the gravity driven term in the equilibrium distribution, thus\n\nf_i^texteq = h bigg(1 - frac23u^2bigg)quad i=0 newline f_i^texteq = w_i h bigg(3 mathbfc_icdotmathbfu + frac92(mathbfc_icdotmathbfu)^2) + frac32u^2bigg)quad else\n\nthen of course the topography gradient has to be included as a force term.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> feq = zeros(5,5,9); ρ = ones(5,5); ux = fill(0.1,5,5); uy = zeros(5,5);\n\njulia> Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5), 0.1) # Supply dummy u^2 as well.\n\njulia> feq[:,:,1]\n5×5 Matrix{Float64}:\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n\njulia> Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5), 0.0) # Supply dummy u^2 as well.\n\njulia> @test all(feq[:,:,1] .≈ 1 - 2/3 * 0.01)\nTest Passed\n\nReferences\n\nSalmon\nDellar\nPeng et al.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.BGKandStream!-NTuple{6, Any}","page":"Functions","title":"Swalbe.BGKandStream!","text":"BGKandStream!(fout, feq, ftemp, Fx, Fy, τ)\n\nPerforms a BGK collision operation with a WFM forcecorrection and a subsequent streaming of the resulting populations.\n\nArguments\n\nfout :: Array{<:Number,3}: Streamed distribution after the collision processes\nfeq :: Array{<:Number,3}: Equilibrium distribution, computed with equilibrium!\nftemp :: Array{<:Number,3}: Temporary distribution from the time step before, only useful if tau neq 1\nFx :: Array{<:Number,2}: Sum of forces acting on the fluid in x-direction\nFy :: Array{<:Number,2}: Sum of forces acting on the fluid in y-direction\nτ <: Number: Relaxtion time, if not supplied tau = 1 assumed\n\nMathematics\n\nThe lattice Boltzmann equation in its discretized format is relatively simple to write down\n\nf_alpha(mathbfx+mathbfe_alphaDelta t t+Delta t) - f_alpha(mathbfx t) = -frac1tau(f_alpha(mathbfx t) - f^texteq_alpha(mathbfx t)) + Delta t mathcalS_alpha\n\nwhere the collision kernel is approximated with a BKG single relaxation time (SRT) \n\nOmega_alpha = frac1tau(f_alpha(mathbfx t) - f^texteq_alpha(mathbfx t)\n\nand a source term mathcalS which is given by\n\nmathcalS_alpha = frac3 w_alphae_alpha xe_alpha x+e_alpha ye_alpha ymathbfe_alphacdotmathbfF_alpha \n\nThe term e_alpha xe_alpha x+e_alpha ye_alpha y is either zero for the zeroth population, 1 for the first four populations or 2 for the remaining ones.\n\nExamples\n\njulia> using Swalbe\n\njulia> feq = ones(5,5,9); ftemp = zeros(5,5,9); fout = zeros(5,5,9);\n\njulia> feq[1,1,:] .= 2.0 # To check the streaming process \n9-element view(::Array{Float64, 3}, 1, 1, :) with eltype Float64:\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n\njulia> Swalbe.BGKandStream!(fout, feq, ftemp, zeros(5,5), zeros(5,5), 1.0)\n\njulia> fout[:,:,6] # The value 2 should have moved one down and one to the right!\n5×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  2.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n\n\nReferences\n\nSalmon\nDellar\nPeng et al.\n\nSee also: Swalbe.equilibrium!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.BGKandStream!-Tuple{Any, Any, Any, Vector, Any}","page":"Functions","title":"Swalbe.BGKandStream!","text":"BGKandStream!(fout, feq, ftemp, F::Vector, τ)\n\nPerforms a BGK collision operation with a WFM forcecorrection and a subsequent streaming of the resulting populations.\n\nArguments\n\nfout :: Array{<:Number,3}: Streamed distribution after the collision processes\nfeq :: Array{<:Number,3}: Equilibrium distribution, computed with equilibrium!\nftemp :: Array{<:Number,3}: Temporary distribution from the time step before, only useful if tau neq 1\nF :: Vector{<:Number,2}: Sum of forces acting on the fluid\nτ <: Number: Relaxtion time, if not supplied tau = 1 assumed\n\nSee also: Swalbe.equilibrium!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.BGKandStream!-Tuple{Swalbe.LBM_state_2D, Swalbe.SysConst}","page":"Functions","title":"Swalbe.BGKandStream!","text":"BGKandStream!(state, sys; τ=sys.param.τ)\n\nPerforms a BGK collision operation with a WFM forcecorrection and a subsequent streaming of the resulting populations.\n\nArguments\n\nstate <: LBM_state: State data structure, works for every state related data structure\nsys :: SysConst: SysConst data structure with τ as parameter\nτ :: Float64: relaxation time, default τ=sys.param.τ\n\nExamples\n\njulia> using Swalbe\n\njulia> sys = Swalbe.SysConst{Float64}(Lx=5, Ly=5, param=Swalbe.Taumucs()); state = Swalbe.Sys(sys, \"CPU\");\n\njulia> state.feq[1,1,:] .= 2.0 # To check the streaming process \n9-element view(::Array{Float64, 3}, 1, 1, :) with eltype Float64:\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n\njulia> Swalbe.BGKandStream!(state, sys)\n\njulia> state.fout[:,:,6] # The value 2 should have moved one down and one to the right!\n5×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n\n\nSee also: Swalbe.equilibrium!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.viewdists-Tuple{Any}","page":"Functions","title":"Swalbe.viewdists","text":"viewdists(f)\n\nGenerates a view for all nine populations of a D2Q9 distribution function.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> ftest = reshape(collect(1.0:225.0),5,5,9);\n\njulia> f0, f1, f2, f3, f4, f5, f6, f7, f8 = Swalbe.viewdists(ftest);\n\njulia> @test all(f3 .== ftest[:,:,4])\nTest Passed\n\nSee also: Swalbe.BGKandStream!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.viewdists_1D-Tuple{Any}","page":"Functions","title":"Swalbe.viewdists_1D","text":"viewdists_1D(f)\n\nGenerates a view for all three populations of a D1Q3 distribution function.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> ftest = reshape(collect(1.0:30.0),10,3);\n\njulia> f0, f1, f2 = Swalbe.viewdists_1D(ftest);\n\njulia> @test all(f1 .== ftest[:,2])\nTest Passed\n\nSee also: Swalbe.BGKandStream!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.moments!-NTuple{4, Any}","page":"Functions","title":"Swalbe.moments!","text":"moments!(height, velx, vely, fout)\n\nComputation of the hydrodynamic moments, height and velocity.\n\nMathematics\n\nThe macroscopic quantities such as the height and the velocity are the moments of the distribution function, \n\nh(mathbfxt) = sum_i=0^8 f_i \n\nand \n\nmathbfv(mathbfxt) = frac1hsum_i=0^8 mathbfc_i f_i \n\nExamples\n\njulia> using Swalbe, Test\n\njulia> fout = zeros(5,5,9); fout[:,:,1] .= 1.0; fout[:,:,2] .= 0.1; # Dist with artifical velocity in x\n\njulia> height = zeros(5,5); velx = zeros(5,5); vely = zeros(5,5);\n\njulia> Swalbe.moments!(height,velx,vely,fout)\n\njulia> @test all(height .== 1.1)\nTest Passed\n\njulia> @test all(velx .== 0.1/1.1)\nTest Passed\n\njulia> @test all(vely .== 0.0)\nTest Passed\n\nReferences\n\nKrüger\nSalmon\nZitz, Scagliarini and Harting\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.h∇p!-Tuple{Swalbe.LBM_state_2D}","page":"Functions","title":"Swalbe.h∇p!","text":"h∇p!(state)\n\nComputation of the pressure gradient multiplied with the height.\n\nMathematics\n\nThe pressure gradient (nabla p) is the driving force of the standard thin film equation partial_t h = (M(h)nabla p). Our approach however does not solve the thin film equation directly, Instead we have to add the pressure gradient as a force which is given as\n\nF_film = -frac1rho_0 h nabla p_film\n\nwhere the term p_film describes the film pressure \n\np_film = -gamma Delta h - Pi(h) \n\nAs such it is the combination of a laplacian term that minimizes the surface area as well as a interfacial potential between substrate and fluid.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> state = Swalbe.Sys(Swalbe.SysConst(Lx=10, Ly=10, param=Swalbe.Taumucs()), \"CPU\");\n\njulia> state.pressure .= reshape(collect(1:100),10,10);\n\njulia> Swalbe.h∇p!(state)\n\njulia> @test all(state.h∇px[1,:] .== -4.0) # at boundary\nTest Passed\n\njulia> @test all(state.h∇px[2,:] .== 1.0) # inside\nTest Passed\n\nReferences\n\nZitz, Scagliarini and Harting\nCraster, Matar\nOron, Davis and Bankoff\n\nSee also: Swalbe.filmpressure!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.inclination!-Tuple{Vector, Swalbe.LBM_state_2D}","page":"Functions","title":"Swalbe.inclination!","text":"inclination!(α, state)\n\nForce that mimics the effect of an inclined plate.\n\nSimple model to add a body force on the fluid that should mimic the effect of an inclined plate. The model includes a smoothing tanh function to absorb shocks which might occure.\n\nArguments\n\n-α :: Vector: Force vector that both hosts direction of the force as well as strength -state::State: Lattice Boltzmann state of the fluid, here we need the state.Fx, state.Fy fields -t::Int: Time step, used for the smoothing tanh factor -tstart::Int: Time delay at which the tanh becomes positve -tsmooth::Int: Time interval over which the tanh is smeared\n\nMathematics\n\nThis body force is simply force strength time the mass of the fluid or even simpler the height (assuming ρ=1). Thus the force becomes\n\nmathbfF = mathbfalpha h tanhbigg(fract-t_0t_sbigg)\n\nwith t_0 being the time lag at which the tanh changes sign and t_s is width of interval between -1 and 1.\n\nSee also: Swalbe.run_dropletforced\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.slippage!-NTuple{7, Any}","page":"Functions","title":"Swalbe.slippage!","text":"slippage!(slipx, slipy, height, velx, vely, δ, μ)\n\nFluid substrate interaction that effectively mimics a velocity boundary condition at h=0.\n\nArguments\n\nslipx :: Array{<:Number,2}: The x-component of the force due the velocity boundary condition\nslipy :: Array{<:Number,2}: The y-component of the force due the velocity boundary condition\nheight::Array{<:Number,2}: Height field h(mathbfxt)\nvelx::Array{<:Number,2}: x-component of the macroscopic velocity vector\nvely::Array{<:Number,2}: y-component of the macroscopic velocity vector\nδ <: Number: Extrapolation length into the substrate where the no-slip is met\nμ <: Number: Kinematic viscosity of the simulation, dependent on the value of τ\n\nMathematics\n\nWith the velocity boundary condition at the fluid substrate interface we build the second main descriptor between our model and the thin film equation. One well studied assumption is that the fluid velocity vanishes at h(mathbfx) = 0 which is called no-slip condition. In terms of thin film mobility M(h) this means \n\nM(h) = frach^33mu\n\nThis assumption, however, can be relaxed to allow for some slippage with a further parameter δ which determines the slip length. The here presented model matches the thin film equation by modification of the momentum equation of the shallow water model. Therefore the force we add to the momentum equation to compensate for the substrate fluid friction is given as\n\nF_fric = -nu alpha_delta(h)mathbfu\n\nwhere ν is the kinematic viscosity and α \n\nalpha_delta(h) = frac6h2h^2 + 6hdelta +3delta^2\n\nand δ being the slip length, or the distance inside the substrate where the fluids velocity vanishes.\n\nReferences\n\nZitz, Scagliarini and Harting\nMünch, Wagner und Witelski\nOron, Davis and Bankoff\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.slippage_ring_riv!-NTuple{8, Any}","page":"Functions","title":"Swalbe.slippage_ring_riv!","text":"slippage_ring_riv!(slipx, slipy, height, velx, vely, δ, μ)\n\nMinor modification that disregards the δ square term in the force calculation. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.thermal!-NTuple{6, Any}","page":"Functions","title":"Swalbe.thermal!","text":"thermal!(fx, fy, height, kᵦT, μ, δ)\n\nComputations of force due to thermal fluctuations.\n\nArguments\n\nfx :: Array{<:Number,2}: x-component of the force due to the fluctuations\nfy :: Array{<:Number,2}: y-component of the force due to the fluctuations\nheight :: Array{<:Number,2}: Height field h(mathbfxt)\nkᵦT <: Number: Strenght of thermal fluctuations in lattice units\nμ <: Number: The kinetic viscosity\nδ <: Number: Slip length, needed to normalize\n\nMathematics\n\nThe classical thin film equation is an equation without thermal noise which is defined as\n\npartial_t h = nablacdot(M(h)nabla p)\n\nClassically thermal excitations are neglected for thin film flows. It is of course possible to introduce for example an envolving surface tension or viscosity but both do not account for e.g. the spectrum of thermal capillary waves. The reason for this short coming is the complex from the thin film equation takes if derived from the Landau-Lifshitz Navier-Stokes equation. One addition term due to the stochastic stress tensor makes it somewhat impossible to solve the eqaution self-consistently. However Grün et al. showed that it is not nessary to use the full stochastic stress tensor, but simple a multiplicative noise term\n\npartial_t h = nablacdotM(h)(nabla p + sigma mathcalN\n\nwhere sigma and mathcalN are a dimensionless temperture and a gaussian white noise. Similar to the pressure gradient the addition of this term is introduced as force in our model\n\nF_fluc = frac1rho_0sqrt2k_BTmualpha_delta(h)mathcalN\n\nwith alpha_delta(h) being the force generated due to substrate slip. \n\nExamples\n\njulia> using Swalbe, Statistics, Test, Random\n\njulia> Random.seed!(1234); # Set a seed\n\njulia> x = ones(50,50); y = ones(50,50); h = ones(50,50);\n\njulia> Swalbe.thermal!(x, y, h, 0.1, 1/6, 1)\n\njulia> @test mean(x) ≈ 0.0 atol=1e-2\nTest Passed\n\njulia> @test mean(y) ≈ 0.0 atol=1e-2\nTest Passed\n\njulia> @test var(x) ≈ 2*0.1/11 atol=(2*0.1/11)/10 # var = 2kbt*6*μ/slip\nTest Passed\n\nReferences\n\nGrün, Mecke and Rauscher\nMecke, Rauscher\nDavidovitch, Moro and Stone\n\nSee also: Swalbe.slippage!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.update_rho!-NTuple{5, Any}","page":"Functions","title":"Swalbe.update_rho!","text":"update_rho()\n\nTime evolution of the active field rho.\n\nTODO: @Tilman!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.view_four-Tuple{Any}","page":"Functions","title":"Swalbe.view_four","text":"view_four()\n\nSplits a chuck of memory in four equivalent chucks\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.∇γ!-Tuple{T} where T<:Swalbe.Expanded_1D","page":"Functions","title":"Swalbe.∇γ!","text":"surface_tension_gradient!(state)\n\nComputes the gradient of a spatially resolved surface tension field.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.fast_32-Tuple{Float64}","page":"Functions","title":"Swalbe.fast_32","text":"fast_32(arg)\n\nQuick computation of a power law potential see filmpressure!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.fast_93-Tuple{Float64}","page":"Functions","title":"Swalbe.fast_93","text":"fast_93(arg)\n\nQuick computation of a power law potential see filmpressure!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.filmpressure!-NTuple{9, Any}","page":"Functions","title":"Swalbe.filmpressure!","text":"filmpressure!(pressure, height, γ, θ, n, m, hmin, hcrit)\n\nCalculation of the capillary pressure which is given by p = - γ²h+ Π(h).\n\nArguments\n\npressure :: Array{Number,2}: Array that store the result of the compuation\nheight :: Array{Number,2}: Height field h(mathbfxt)\nγ <: Number: Forcing strenght due to surface tension\nθ <: Number: Equilibrium contact angle\nn :: Int: Larger power law exponent for Π(h)\nm :: Int: Smaller power law exponent for Π(h)\nhmin <: Number: Parameter of Π(h), in fact Π(hmin) = 0\nhcrit <: Number: Numerical stabilizer for case h(mathbfxt) ll hmin\n\nMathematics\n\nThe capillary pressure p_textcap is the centeral angle to match our model with the thin film equation. It consists of two parts, first being the laplace pressure nabla^2 h and second being the derivative of the disjoining pontential Pi(h)\n\np_textcap = -gamma nabla^2 h + Pi(h)\n\nFor the laplacian term we use the same nine point discretization as in Swlabe.∇²f!. Pi(h) on the other hand is given by \n\nPi(h) = kappa(theta)f(h)\n\nwhere kappa(theta) is simply a measure for the Hamaker constant and given as\n\nkappa(theta) = gamma(1- cos(theta))frac(n-1)(m-1)(n-m)h_textmin\n\nFor f(h) one can use various forms, a very common however is the power law given by \n\nf(h) = biggbigg(frach_textminhbigg)^n - bigg(frach_textminhbigg)^mbigg\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> h = reshape(collect(1.0:25.0),5,5) # A dummy height field\n5×5 Matrix{Float64}:\n 1.0   6.0  11.0  16.0  21.0\n 2.0   7.0  12.0  17.0  22.0\n 3.0   8.0  13.0  18.0  23.0\n 4.0   9.0  14.0  19.0  24.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> pressure = zeros(5,5); θ = 0.0; # Fully wetting substrate\n\njulia> Swalbe.filmpressure!(pressure, h, zeros(5,5,8), 0.01, 0.0, 3, 2, 0.1, 0.05) # default γ = 0.01\n\njulia> result = [30.0 5.0 5.0 5.0 -20;\n                 25.0 0.0 0.0 0.0 -25.0;\n                 25.0 0.0 0.0 0.0 -25.0;\n                 25.0 0.0 0.0 0.0 -25.0;\n                 20.0 -5.0 -5.0 -5.0 -30.0];\n\njulia> for i in eachindex(result)\n           @test result[i] .≈ -100 .* pressure[i] atol=1e-12\n       end\n\nReferences\n\nPeschka et al.\nCraster and Matar\nDerjaguin and Churaev\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.power_2-Tuple{Float64}","page":"Functions","title":"Swalbe.power_2","text":"power_2(arg)\n\nPower two (arg^2) computation of a Float64 number.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.power_3-Tuple{Float64}","page":"Functions","title":"Swalbe.power_3","text":"power_3(arg)\n\nPower three (arg^3) computation of a Float64 number.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.power_broad-Tuple{Float64, Int64}","page":"Functions","title":"Swalbe.power_broad","text":"power_broad(arg, n)\n\nComputes arg to the power n.\n\nActually this is useful because the ^ operator is much slower. Same thing I learned about the pow function in C, * yes it does what you want, but it is slow as fuck *.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> Swalbe.power_broad(3, 3)\n27\n\njulia> Swalbe.power_broad.([2.0 5.0 6.0], 2) # Use the broadcasting operator `.`\n1×3 Matrix{Float64}:\n 4.0  25.0  36.0\n\n\nSee also: filmpressure!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.viewneighbors-Tuple{Any}","page":"Functions","title":"Swalbe.viewneighbors","text":"viewneighbors(f)\n\nGenerates a view for all nine populations of a D2Q9 distribution function.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> ftest = reshape(collect(1.0:5*5*8),5,5,8);\n\njulia> f1, f2, f3, f4, f5, f6, f7, f8 = Swalbe.viewneighbors(ftest);\n\njulia> @test all(f3 .== ftest[:,:,3])\nTest Passed\n\nSee also: Swalbe.∇f!, Swalbe.filmpressure!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.viewneighbors_1D-Tuple{Any}","page":"Functions","title":"Swalbe.viewneighbors_1D","text":"viewneighbors_1D(f)\n\nGenerates a view for the two neighbors of a D1Q3 distribution function.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> ftest = reshape(collect(1.0:30),10,3);\n\njulia> f1, f2 = Swalbe.viewneighbors_1D(ftest);\n\njulia> @test all(f2 .== ftest[:,2])\nTest Passed\n\nSee also: Swalbe.∇f!, Swalbe.filmpressure!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.∇f!-Tuple{Any, Any, Any}","page":"Functions","title":"Swalbe.∇f!","text":"∇f!(outputx, outputy, f)\n\nGradient calculation with finite differences.\n\nComputes both spatial first derivatives with a nine point stencil from an input f and writes the result to outputx and outputy. Since broadcasting is simple on the GPU we make use of circshift for the neighbors.\n\nMathematics\n\nThe gardient in two dimensions is given as\n\nnabla f = big(fracpartial fpartial x fracpartial fpartial ybig)^T \n\nAgain with the nine point stencil this reduces to \n\nfracpartial fpartial x = frac13 (f_i+1j - f_i-1j) + frac112(f_i+1j+1 - f_i-1j+1 - f_i-1j-1 + f_i+1j-1) \n\nand for the y component we get\n\nfracpartial fpartial y = frac13 (f_ij+1 - f_ij-1) + frac112(f_i+1j+1 + f_i-1j+1 - f_i-1j-1 - f_i+1j-1) \n\nFor the exact derivation feel free to read the reference by Junk and Klar.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> arg = reshape(collect(1.0:25),5,5)\n5×5 Matrix{Float64}:\n 1.0   6.0  11.0  16.0  21.0\n 2.0   7.0  12.0  17.0  22.0\n 3.0   8.0  13.0  18.0  23.0\n 4.0   9.0  14.0  19.0  24.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> resx = zeros(5,5); resy = zeros(5,5); Swalbe.∇f!(resx, resy, arg)\n\njulia> whatXshouldbe = [-1.5 -1.5 -1.5 -1.5 -1.5;\n                         1.0 1.0 1.0 1.0 1.0;\n                         1.0 1.0 1.0 1.0 1.0;\n                         1.0 1.0 1.0 1.0 1.0;\n                        -1.5 -1.5 -1.5 -1.5 -1.5];\n\njulia> for i in eachindex(resx) # Test the x-component\n           @test resx[i] ≈ whatXshouldbe[i] atol=1e-10\n       end\n\njulia> whatYshouldbe = [-7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5];\n\njulia> for i in eachindex(resy) # Test the y-component\n           @test resy[i] ≈ whatYshouldbe[i] atol=1e-10\n       end\n\nReferences\n\nJunk & Klar\nSucci et al.\n\nSee also: Swalbe.∇²f!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.∇²f!-Tuple{Any, Any, Any}","page":"Functions","title":"Swalbe.∇²f!","text":"∇²f!(output, f, γ)\n\nFinite difference operator for a second derivative in two dimensions.\n\nComputes the laplacian of an input f times a scalar γ and stores the result in output.\n\nMathematics\n\nThe laplacian operator in two dimensions can be written as\n\nnabla^2 f = fracpartial^2 fpartial x^2 + fracpartial^2 fpartial y\n\nFor the discretization of this operator we use a nine point stencil, such the neighbors as well as the diagonal elements. The concrete derivation can be found in the references below, we just show the final result\n\nnabla^2 f = frac16bigg4(f_i+1j + f_ij+1 + f_i-1j + f_ij-1) newline                 qquadqquad +(f_i+1j+1 + f_i-1j+1 + f_i-1j-1 + f_i+1j-1) newline                 qquadqquad -20f_ijbigg  \n\nwhere we have used Julia conventions, downwards (left) is positive.  The whole expression can be multiplied with a scalar γ if needed.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> arg = reshape(collect(1.0:25),5,5)\n5×5 Matrix{Float64}:\n 1.0   6.0  11.0  16.0  21.0\n 2.0   7.0  12.0  17.0  22.0\n 3.0   8.0  13.0  18.0  23.0\n 4.0   9.0  14.0  19.0  24.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> res = zeros(5,5); Swalbe.∇²f!(res, arg, -1.0)\n\njulia> analytics = [-30.0 -5.0 -5.0 -5.0 20;\n                    -25.0 0.0 0.0 0.0 25.0;\n                    -25.0 0.0 0.0 0.0 25.0;\n                    -25.0 0.0 0.0 0.0 25.0;\n                    -20.0 5.0 5.0 5.0 30.0];\n\njulia> for i in eachindex(analytics)\n           @test analytics[i] ≈ res[i] atol=1e-10\n       end\n\nReferences\n\nJunk & Klar\nSucci et al.\n\nSee also: Swalbe.∇f!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.CuState","page":"Functions","title":"Swalbe.CuState","text":"CuState\n\nState data structure but for CUDA like memory.\n\nSimilar to CuState_thermal without the thermal fields.\n\nArguments\n\nfout :: CUDA.CuArray{T,N}: Output distribution function\nftemp :: CUDA.CuArray{T,N}: Temporary distribution function, only used if sys.τ ≠ 1\nfeq :: CUDA.CuArray{T,N}: Equilibrium distribution function\nheight :: CUDA.CuArray{T}: Field that stores the scalar height values\nvelx :: CuMatrix{T}: Field that stores the x-component of the velocity vector\nvely :: Matrix{T}: Field that stores the y-component of the velocity vector\nvsq :: Matrix{T}: Field that stores the velocity squared, used in equilibrium!\npressure :: Matrix{T}: Pressure distribution computed using the filmpressure! function\nFx :: Matrix{T}: Total force acting on the fluid, x-component\nFy :: Matrix{T}: Total force acting on the fluid, y-component\nslipx :: Matrix{T}: Friction force due to substrate slip, x-component\nslipy :: Matrix{T}: Friction force due to substrate slip, y-component\nh∇px :: Matrix{T}: Pressure gradient times the height, x-component\nh∇py :: Matrix{T}: Pressure gradient times the height, y-component\ndgrad :: Array{T,N}: Dummy allocation to store shifted arrays using circshift!\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.State","page":"Functions","title":"Swalbe.State","text":"State{T, N}\n\nData structure for both macroscopic variables and distribution functions.\n\nArguments\n\nfout :: Array{T,N}: Output distribution function\nftemp :: Array{T,N}: Temporary distribution function, only used if sys.τ ≠ 1\nfeq :: Array{T,N}: Equilibrium distribution function\nheight :: Matrix{T}: Field that stores the scalar height values\nvelx :: Matrix{T}: Field that stores the x-component of the velocity vector\nvely :: Matrix{T}: Field that stores the y-component of the velocity vector\nvsq :: Matrix{T}: Field that stores the velocity squared, used in equilibrium!\npressure :: Matrix{T}: Pressure distribution computed using the filmpressure! function\nFx :: Matrix{T}: Total force acting on the fluid, x-component\nFy :: Matrix{T}: Total force acting on the fluid, y-component\nslipx :: Matrix{T}: Friction force due to substrate slip, x-component\nslipy :: Matrix{T}: Friction force due to substrate slip, y-component\nh∇px :: Matrix{T}: Pressure gradient times the height, x-component\nh∇py :: Matrix{T}: Pressure gradient times the height, y-component\ndgrad :: Array{T,N}: Dummy allocation to store shifted arrays using circshift!\n\nSee also: State_thermal{T, N}, CuState, State_1D{T, N}\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.StateWithBound_1D","page":"Functions","title":"Swalbe.StateWithBound_1D","text":"StateWithBound_1D{T, N}\n\nData structure that stores all arrays for a given simulation.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.State_1D","page":"Functions","title":"Swalbe.State_1D","text":"State_1D{T, N}\n\nData structure that for a one dimensional simulation.\n\nArguments\n\nfout :: Matrix{T}: Output distribution function\nftemp :: Matrix{T}: Temporary distribution function, only used if sys.τ ≠ 1\nfeq :: Matrix{T}: Equilibrium distribution function\nheight :: Vector{T}: Field that stores the scalar height values\nvel :: Vector{T}: Field that stores the velocity\npressure :: Vector{T}: Pressure distribution computed using the filmpressure! function\nF :: Vector{T}: Total force acting on the fluid\nslip :: Vector{T}: Friction force due to substrate slip\nh∇p :: Vector{T}: Pressure gradient times the height\ndgrad :: Matrix{T}: Dummy allocation to store shifted arrays using circshift!\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.State_gamma_1D","page":"Functions","title":"Swalbe.State_gamma_1D","text":"State_gamma_1D{T, N}\n\nState_1D data structure with additional fields for surface tension γ and ∇γ.\n\nArguments\n\nbasestate :: State_1D{T}: Base data structure for one dimensional simulations\nγ :: Vector{T}: Surface tension field\n∇γ :: Vector{T}: Surface tension gardient\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.State_thermal","page":"Functions","title":"Swalbe.State_thermal","text":"State_thermal{T, N}\n\nData structure that contains a State and fields for thermal fluctuations.\n\nArguments\n\nbasestate :: State{T,N}: State data structer\nkbtx :: Matrix{T}: Force due to thermal fluctuations, x-component\nkbty :: Matrix{T}: Force due to thermal fluctuations, y-component\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.State_thermal_1D","page":"Functions","title":"Swalbe.State_thermal_1D","text":"State_thermal_1D{T, N}\n\nState_1D data structure with additional fields for thermal fluctuations (noise).\n\nArguments\n\nbasestate :: State_1D{T}: Base data structure for one dimensional simulations\nkbt :: Vector{T}: Surface tension field\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.SysConst","page":"Functions","title":"Swalbe.SysConst","text":"SysConst{T}\n\nStruct that contains the system size of a two dimensional system and the struct Taumucs.\n\nArguments\n\nLx :: Int: Length of the lattice sides in x-direction\nLy :: Int: Length of the lattice sides in y-direction\ns :: Taumucs : Most of the run time constants\n\nSee also: SysConst_1D{T}, Taumucs{T}\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.SysConstWithBound_1D","page":"Functions","title":"Swalbe.SysConstWithBound_1D","text":"SysConstWithBound_1D{T}\n\nStruct that contains all run time constants, e.g. lattice size, surface tension γ and so on.\n\nArguments\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.SysConst_1D","page":"Functions","title":"Swalbe.SysConst_1D","text":"SysConst_1D{T}\n\nStruct that contains the system size of a one dimensional system and the struct Taumucs.\n\nArguments\n\nL :: Int: Number of lattice points\ns :: Taumucs: Most of the run time constants\n\nSee also: SysConst{T}, Taumucs{T}\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.Taumucs","page":"Functions","title":"Swalbe.Taumucs","text":"Taumucs{T}\n\nStruct that contains most run time constants, e.g. surface tension γ, viscosity μ and so on.\n\nArguments\n\nTmax :: Int: Number of lattice Boltzmann time iterations\ntdump :: Int: Dumping interval for e.g. data output\nτ :: T: BGK relaxation rate \ncₛ :: T: Lattice speed of sound, every physical velocity needs to be smaller than this! \nμ :: T: Kinematic fluid viscosity\nδ :: T: Slip length, defines how far the no-slip condition is interpolated into the substrate\nkbt :: T: Thermal energy of the film, works with small values ≈ 10^(-7)\nγ :: T: Surface tension\nn :: Int: Greater exponent of the two used for the powerlaw in the disjoining pressure\nm :: Int: Smaller exponent of the two used for the powerlaw in the disjoining pressure\nhmin :: T: Height value at which the disjoining pressure functional vanishes\nhcrit :: T: Numerical stabilizer for the disjoining pressure term\nθ :: T: Contact angle in multiples of π\ng :: T: gravitational acceleration, usually neglected in thin film simulations\n\nSee also: SysConst{T}, SysConst_1D{T}\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.Sys-Tuple{Swalbe.Consts_1D}","page":"Functions","title":"Swalbe.Sys","text":"Sys(sysc, T, kind)\n\nAllocations of arrays used to run a one dimensional simulation.\n\nReturns a State data structure based on kind the struct can be \"simple\", \"thermal\" or \"gamma\".\n\nArguments\n\nsysc :: SysConst_1D: Stores the lattice size L \nT <: Number: Optional numerical type, default is set to Float64\nkind :: String: Optional, default is set to simple\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.Sys-Tuple{Swalbe.SysConst, String, Bool, Any}","page":"Functions","title":"Swalbe.Sys","text":"Sys(sysc, device, exotic, T)\n\nMostly allocations of arrays used to run a simulation, but all within one function :)\n\nReturns not a data structure such as state, but every array. Therefore it is somewhat outdated by now (2022).\n\nArguments\n\nsysc :: SysConst: Needed for the lattice dimensions, Lx and Ly\ndevice :: String: Use either CPU for computation of a CPU or GPU for computation on the GPU \nexotic :: Bool: If true thermal fluctuations can be computed and saved to the fthermalx and fthermaly field\nT <: Number: Numerical type, it is strongly suggested to use Float64\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.Sys-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.Sys","text":"Sys(sysc, device; T, kind)\n\nAllocations of arrays used to populate the State data structure.\n\nReturns a State data structure based on sysc, either one dimensional or two dimensional.\n\nArguments\n\nsysc :: SysConst: Needed for the lattice dimensions, Lx and Ly\ndevice :: String: Use either CPU for computation of a CPU or GPU for computation on the GPU (GPU can only be used with a two dimensional system)\nT <: Number: Numerical type, it is strongly suggested to use Float64\nkind :: String: Indicator for different State's, default value is \"simple\" which creates a State data structure, valid options are [\"simple\", \"thermal\"] \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.obslist!-Tuple{Swalbe.SysConstWithBound_1D}","page":"Functions","title":"Swalbe.obslist!","text":"function obslist1D!(sys::SysConstWithBound; T=Float64, verbose=false)\n\nUpdates interior and border according to obs. See obslist().\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.obslist1D-Tuple{Any}","page":"Functions","title":"Swalbe.obslist1D","text":"function obslist1D(obs) Returns a list containing the relevgant obstacle nodes constructed from interior, obsleft, obsright, obsup, obsdown, corneroutlu, corneroutld, corneroutru, corneroutrd, cornerru, cornerrd, cornerlu, cornerld\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.boxpattern-Tuple{Any, Any}","page":"Functions","title":"Swalbe.boxpattern","text":"boxpattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=20)\n\nDefines a quadratic box around a center with side length side.\n\nArguments\n\nθ::Array{undef,2}: Contact angle map\nθ₀: Default contact angle θ\ncenter::Tuple{Int, Int}: center of the box pattern, default value is (size(θ,1)÷2, size(θ,2)÷2)\nδₐ::Float64: Contact angle contrast with the substrate, default is set to 1/36 ≈ 5 degrees difference\nside::Int: Length of the sides, default is set to 20\n\nExamples\n\njulia> using Swalbe\n\njulia> θ₀ = 1/9;\n\njulia> pattern, polygon = Swalbe.boxpattern(ones(100,100), θ₀);\n\njulia> polygon # Some cool thing we use to create the posize(θ,2)gones, a LazySet\nLazySets.VPolygonModule.VPolygon{Float64, Vector{Float64}}([[40.0, 40.0], [60.0, 40.0], [60.0, 60.0], [40.0, 60.0]])\n\njulia> pattern[50,50] == pattern[1,1] # In the center there is a different contact angle!\nfalse\n\n\nReferences\n\nReally not much to say here, check out LazySets.jl.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.ellipsepattern-Tuple{Any, Any}","page":"Functions","title":"Swalbe.ellipsepattern","text":"ellipsepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, a=10, b=5)\n\nCreates an ellipse shaped contact angle defect with contact angle mismatch δₐ.\n\nArguments\n\nθ::Array{undef,2}: Contact angle map\nθ₀: Default contact angle θ\ncenter::Tuple{Int, Int}: center of the created pattern, default values is center = (size(θ,1)÷2, size(θ,2)÷2)\nδₐ::Float64: contact angle mismatch between patch and rest of substrate, default is δₐ = 1/36 or 5 degrees\na::Int:: semimajor half ax of the ellipse, default value is a=10\nb::Int:: semiminor half ax of the ellipse, default value is b=5\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> θ₀ = 1/9;\n\njulia> θ, P = Swalbe.ellipsepattern(ones(100,100), θ₀); # per default the center is in the middle!\n\njulia> @test θ[1,1] == θ₀\nTest Passed\n\njulia> @test θ[50,50] == θ₀ + 1/36 # The default increment, is about 5 degrees.\nTest Passed\n\nReferences\n\nNothing interesting here.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.randinterface!-Tuple{Any, Any, Any}","page":"Functions","title":"Swalbe.randinterface!","text":"randinterface!(height, h₀, ϵ)\n\nCreates a random height field with average height h₀ and displacement magnitude ϵ.  \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.restart_from_height-Tuple{Any}","page":"Functions","title":"Swalbe.restart_from_height","text":"restart_from_height(data)\n\nRestarts a simulation from already generated height data.\n\nArguments\n\ndata::file: Some file with computed data\nkind::String: File format, .bson or .jld2 are valid options\ntimestep::Int: The time step the height is read from file\nsize::Tuple{Int,Int}: x and y limits of the computational domain\n\njulia> using Swalbe, FileIO, Test\n\njulia> h1 = rand(10,10); h2 = rand(10,10);\n\njulia> f = Dict() # For storage\nDict{Any, Any}()\n\njulia> f[\"h_1\"] = vec(h1); f[\"h_2\"] = vec(h2);\n\njulia> save(\"file.jld2\", f)\n\njulia> h = Swalbe.restart_from_height(\"file.jld2\", timestep=1, size=(10,10));\n\njulia> @test all(h .== h1)\nTest Passed\n\njulia> rm(\"file.jld2\")\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.rivulet","page":"Functions","title":"Swalbe.rivulet","text":"rivulet(sys; radius, θ, center)\n\nGenerates a rivulet with contact angle θ, sphere radius radius and centered at center.\n\nArguments\n\nsys::SysConst{T}: Contains size of the domain\nradius::AbstractFloat: radius of the underlying sphere from which the spherical cap is cut\nθ::AbstractFloat: contact angle in multiples of π\norientation::Symbol: extrusion direction of cap shape\ncenter::Int: coordinate of the center of the cap\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> rad = 45; c = 100; sys = Swalbe.SysConst(Lx=200, Ly=200, param=Swalbe.Taumucs());\n\njulia> height = Swalbe.rivulet(sys, rad, :y, c);\n\njulia> @test maximum(height) == rad * (1 - cospi(sys.param.θ)) # Simple geometry\nTest Passed\n\njulia> argmax(height) # Which is constistent with the center!\nCartesianIndex(100, 1)\n\n\nReferences\n\nSee also: singledroplet, two_droplets\n\n\n\n\n\n","category":"function"},{"location":"functions/#Swalbe.sinewave1D!-Tuple{Any, Any, Int64, Any, Int64}","page":"Functions","title":"Swalbe.sinewave1D!","text":"sinewave1D!(height, h₀, n, ϵ)\n\nCreates a sine wave like height field with n full waves, average height h₀ and displacement magnitude ϵ.  \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.singledroplet-NTuple{4, Any}","page":"Functions","title":"Swalbe.singledroplet","text":"singledroplet(height, radius, θ, center)\n\nGenerates a fluid configuration of a single droplet in the shape of spherical cap with contact angle θ, sphere radius radius and centered at center.\n\nArguments\n\nheight::Array{undef, 2}: numerical formate, either Float64 or Float32\nradius::AbstractFloat: radius of the underlying sphere from which the spherical cap is cut off\nθ::AbstractFloat: contact angle in multiples of π\ncenter::Tuple{Int,Int}: x and y coordinates of the center of the droplet\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> rad = 50; θ = 1/3;\n\njulia> height = Swalbe.singledroplet(ones(100,100), rad, θ, (50,50));\n\njulia> @test maximum(height) == rad * (1 - cospi(θ)) # Simple geometry\nTest Passed\n\njulia> argmax(height) # Which is constistent with the center!\nCartesianIndex(50, 50)\n\n\nReferences\n\nSee also: \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.torus","page":"Functions","title":"Swalbe.torus","text":"torus(lx, ly, r₁, R₂, θ, center, hmin)\n\nGenerates a cut torus with contact angle θ, (x,y) radius R₂ and (x,z) radius r₁ centered at center.\n\nArguments\n\nlx::Int: Size of the domain in x-direction\nly::Int: Size of the domain in y-direction\nr₁::AbstractFloat: Radius in (x,z)-plane\nR₂::AbstractFloat: Radius in (x,y)-plane\nθ::AbstractFloat: contact angle in multiples of π\ncenter::Tuple{Int, Int}: Center position of the torus  \nhmin::AbstractFloat: small value above 0.0\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> rad = 45; R = 80; θ = 1/9; center = (128, 128);\n\njulia> height = Swalbe.torus(256, 256, rad, R, θ, center);\n\njulia> @test maximum(height) ≈ rad * (1 - cospi(θ)) # Simple geometry\nTest Passed\n\njulia> argmax(height) # On the outer ring!\nCartesianIndex(128, 48)\n\n\nReferences\n\nSee also: rivulet, singledroplet, two_droplets\n\n\n\n\n\n","category":"function"},{"location":"functions/#Swalbe.trianglepattern-Tuple{Any, Any}","page":"Functions","title":"Swalbe.trianglepattern","text":"trianglepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=60)\n\nGenerates an equilateral triangle centered around center with contact angle contrast δₐ and side length side.\n\nArguments\n\nθ::Array{undef,2}: Contact angle map\nθ₀: Default contact angle θ\ncenter::Tuple(Int, Int): position of the center of the triangle\nδₐ::Float64: contact angle contrast with the rest of the substrate\nside::Int: length of the sides of the equilateral triangle\n\nExamples\n\njulia> using Swalbe\n\njulia> θ, P = Swalbe.trianglepattern(ones(50,50), 1/9, side=20) # Returns a polygon and the contact angle field\n([0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; … ; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111], LazySets.VPolygonModule.VPolygon{Float64, Vector{Float64}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]]))\n\njulia> P\nLazySets.VPolygonModule.VPolygon{Float64, Vector{Float64}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]])\n\njulia> θ[25,25]\n0.1388888888888889\n\nReferences\n\nSee also:\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.two_droplets-Tuple{Swalbe.Consts_1D}","page":"Functions","title":"Swalbe.two_droplets","text":"two_droplets(sys)\n\nGenerates a fluid configuration of a two droplets in the shape of spherical cap with contact angles θ₁, θ₂, sphere radius r₁, r₂ and centers at center.\n\nThis is work in progress, therefore so far it is only available for the lower dimension model.\n\nArguments\n\nr₁::Float64: radius of the first sphere from which the cap is cut of\nr₂::Float64: radius of the second sphere from which the cap is cut of\nθ₁::Float64: contact angle of the first cap in multiples of π\nθ₂::Float64: contact angle of the second cap in multiples of π\ncenter::Tuple{Int,Int}: x coordinates of the centers of the droplets\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> rad = 45; θ = 1/4; sys = Swalbe.SysConst_1D(L=200, param=Swalbe.Taumucs());\n\njulia> height = Swalbe.two_droplets(sys, r₁=rad, r₂=rad, θ₁=θ, θ₂=θ);\n\njulia> @test maximum(height) ≈ rad * (1 - cospi(θ)) atol=0.01 # Simple geometry\nTest Passed\n\nReferences\n\nSee also: \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.fluid_dry!-NTuple{4, Any}","page":"Functions","title":"Swalbe.fluid_dry!","text":"fluid_dry!(fluid, dummy, height, t; hthresh = 0.055)\n\nTracks the location of the thin film as a boolean field.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.snapshot!-Tuple{Any, Any, Any}","page":"Functions","title":"Swalbe.snapshot!","text":"snapshot!(snap, field, t; dumping)\n\nMakes a copy of the current state of an input array in and saves the vectorized values as a column to out.\n\nFunction that fills a preallocated array out with a time series of system snap shots of e.g. the height field h.\n\nArguments\n\nsnap :: Array{Number,2}: Array that stores the snap shots as columns\nfield :: Array{Number,2}: Input argument, e.g. h(mathbfxt)\nt :: Int: The current time step\ndumping :: Int: Sampling frequency\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> h1 = reshape(collect(1:25),5,5); h2 = reshape(collect(5:5:125),5,5);\n\njulia> snapshot = zeros(2, 25);\n\njulia> Swalbe.snapshot!(snapshot,h1,10,dumping=10)\n\njulia> Swalbe.snapshot!(snapshot,h2,20,dumping=10)\n\njulia> @test all(h1 .== reshape(snapshot[1,:],5,5))\nTest Passed\njulia> @test all(h2 .== reshape(snapshot[2,:],5,5))\nTest Passed\n\nReferences\n\nSee also: The scripts folder \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.surfacearea!-Tuple{Any, Any, Any, Float64, Vararg{Any, 5}}","page":"Functions","title":"Swalbe.surfacearea!","text":"surfacearea!(area_lv, red_energy, height, θ, ∇hx, ∇hy, dgrad, surface,)\n\nMeasures the surface area of the liquid vapor interface and the reduced surface energy.\n\nArguments\n\narea_lv :: Vector{Float64}: array to store the computed liquid vapor area\nred_energy :: Vector{Float64}: array the stores the computed reduced surface energy \nheight :: Matrix{Float64}: current height configuration\nθ :: Matrix{Float64}: contact angle field distribution\n∇hx :: Matrix{Float64}: height gradient x-component \n∇hy :: Matrix{Float64}: height gradient y-component\ndgrad :: Array{Float64,3}: dummy array to store derivatives \nsurface :: Matrix{Float64}: array that computes locally the liquid vapor surface area \nt :: Int: current time step\nhthresh :: Float64: height threshold below which the substrate is considered dry\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.t0-Tuple{}","page":"Functions","title":"Swalbe.t0","text":"t0(;hᵦ=0.07, γ=0.01, μ=1/6, θ=1/6)\n\nComputes a characteristic time scale for an spinodally dewetting film.\n\nArguments\n\nhᵦ :: Float64: height at which the disjoining pressure vanishes\nγ :: Float64: surface tension value\nμ :: Float64: kinematic viscosity, same as dynamic for ρ=1\nθ :: Float64: highest contact angle given as radiant, e.g. θ=π/9 for 20 degrees\n\nMathematics\n\nThe charateristic time scale t_0 is set using the surface tension as well as the disjoining pressure Pi(h) as \n\nt_0 = frac3gamma h_0^3 q_0^4 quad q_0 = fracPi(h_0)2gamma\n\nwhere Pi(h_0) = fracpartialPipartial hbigg_h_0 is the derivative of the disjoining pressure with respect to some characteristic height.\n\nReferences\n\nMecke, Rauscher\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.wetted!-NTuple{4, Any}","page":"Functions","title":"Swalbe.wetted!","text":"wetted!(area_size, drop_pos, maxheight, height, t; hthresh = 0.055)\n\nMeasures the wetted area and maximal height of the film at time step t. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.∇f_simple!-NTuple{4, Any}","page":"Functions","title":"Swalbe.∇f_simple!","text":"∇f_simple!(outputx, outputy, f, dgrad)\n\nSimple gradient calculation for the differential surface area.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_dropletforced-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_dropletforced","text":"run_dropletforced()\n\nSimulates a sliding droplet\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_dropletpatterned-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_dropletpatterned","text":"run_dropletpatterned()\n\nSimulates an droplet on a patterned substrate\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_dropletrelax-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_dropletrelax","text":"run_dropletrelax()\n\nSimulates an out of equilibrium droplet\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_flat-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_flat","text":"run_flat(Sys::SysConst, device::String)\n\nPerforms a simulation of an flat interface without forces.\n\nArguments\n\nverbos :: Bool: Enables consol output\nT :: AbstractFloat: Precision of output, default Float64\n\nTheory\n\nNothing at all should happen. As the initial state is falt and no force is applied the fluid has no way to flow. The equality h(mathbfx0) = h(mathbfxinfty) should be satisfied for arbitrary many time steps.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> sys = Swalbe.SysConst(Lx=100, Ly=100, Tmax=5000);\n\njulia> h = Swalbe.run_flat(sys, \"CPU\", verbos=false);\n\njulia> @test all(h.height .== 1.0) # Check if all height values are identical to 1.0 (initial condition)\nTest passed\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_gamma-Tuple{Swalbe.SysConst_1D, Vector}","page":"Functions","title":"Swalbe.run_gamma","text":"run_(sys::Swalbe.SysConst_1D,\n\t gamma::Vector;\n\t r₁=115,\n\t r₂=115, \n\t θ₀=1/9,  \n\t verbos=true, \n\t dump = 100, \n\t fluid=zeros(sys.param.Tmax÷dump, sys.L))\n\nLattice Boltzmann simulation of coalescing droplets.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_random-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_random","text":"run_random(sys::SysConst, device::String)\n\nSimulation of an random undulated interface\n\nArguments\n\nh₀ :: Float : Average initial height\nϵ :: Float : Amplitude of the flucutation\nverbos :: Bool: Enables consol output\nT :: AbstractFloat: Precision of output, default Float64\n\nTheory\n\nInitial randomly perturbed fluid surface. Unstable wavemodes should grow while wavemodes larger q₀ should be damped out. Measuring this is on the TODO list.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> sys = Swalbe.SysConst(Lx=100, Ly=100, Tmax=5000);\n\njulia> Swalbe.randinterface!(height, h₀, ϵ)\n\njulia> h = Swalbe.run_random(sys, \"CPU\", h₀=10, ϵ=0.1, verbos=false);\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_rayleightaylor-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_rayleightaylor","text":"run_rayleightaylor(sys::SysConst, device::String)\n\nSimulation of an random undulated interface and a gravitanional pull.\n\nArguments\n\nkx :: Int : wavemode in x-direction, kx=18 -> 18 sine waves fitting into the domain\nky :: Int : wavemode in y-direction\nh₀ :: Float : Average initial height\nϵ :: Float : Amplitude of the flucutation\nverbos :: Bool: Enables consol output\nT :: AbstractFloat: Precision of output, default Float64\n\nTheory\n\nInitial randomly perturbed fluid surface hanging from a substrate. Here we have an interplay between gravity and surface tension. The critical wavemode can be computed according to  q_0 = Measuring this is on the TODO list.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> sys = Swalbe.SysConst(Lx=100, Ly=100, Tmax=5000);\n\njulia> Swalbe.randinterface!(height, h₀, ϵ)\n\njulia> h = Swalbe.run_random(sys, \"CPU\", h₀=10, ϵ=0.1, verbos=false);\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.time_loop-Tuple{Swalbe.SysConst, Swalbe.LBM_state_2D}","page":"Functions","title":"Swalbe.time_loop","text":"time_loop(sys, state)\n\nTime stepping procedure for the lattice Boltzmann state state given parameters sys\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Swalbe.jl is software that simulates the dynamics of a thin liquid film. At it's core is the lattice Boltzmann method (LBM) a mesoscale method that works based on particle distribtuion functions f_i(mathbfxt). To get a better understandig of both the LBM and the package we supply instructive simulations and discuss the content of the code.","category":"page"},{"location":"tutorials/#Constant-interface","page":"Tutorials","title":"Constant interface","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"A nice and easy way to check the consistency of a fluid mechanics solver is to prob the mass or density. Per continuity equation partial_trho + nablacdotmathbfj = 0, we require that the local density rho can only change if there is a flux mathbfj (okay a divergence of a flux).  In case of vanishing or constant flux nablacdotmathbfj = 0 the density has to be time independent and therefore partial_t rho = 0. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Thin film flows can be described with the same kind of equation","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"partial_t h(mathbfxt) + nablaleft(M(h)nabla p(mathbfxt)right) = 0 ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The local height can only change with time if some pressure gradient ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Having a vanshing pressure gradient the height h(mathbfxt) have to be constant independent of time. To check this we put together a small sample simulation that probes this.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Swalbe # import the package\n\n# Define the system size and parameters\nsys = Swalbe.SysConst(Lx = 100,     # 100 lattice units in x-direction \n                      Ly = 100,     # 100 lattice units in y-direction\n                      Tmax = 1000)  # LBM time loop runs for 1000 iterations\n\n\n# Allocation of distribution functions, macroscopic variables and forces \nfout, ftemp, feq, height, velx, vely, vsq, pressure, dgrad, Fx, Fy, slipx, slipy, h∇px, h∇py = Swalbe.Sys(sys,      # Size \n                                                                                                          \"CPU\",    # Where to run \n                                                                                                          false,    # No fluctuations  \n                                                                                                          Float64)  # Num type\n# Constant film thickness, or flat interface\nheight .= 1.0\n# Compute the first equilibrium distribtuion function based on the initial conditions \nSwalbe.equilibrium!(ftemp, height, velx, vely, vsq)\n# Empty list to measure the total mass over time\nmass = []\n# To add the forcing due to a pressure gradient set true\npressure_gradient = false\n# Start of the lattice Boltzmann time loop\nfor t in 1:sys.Tmax\n    # Fill the list \n    push!(mass,sum(height))\n    # Talks with us all t % tdump time sets\n    if t % sys.tdump == 0\n        println(\"Time step $t mass is $(round(sum(height), digits=3))\")\n    end\n    if pressure_gradient\n        # The pressure computation \n        Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, 1/9, sys.n, sys.m, sys.hmin, sys.hcrit)\n        # Pressure gradient\n        Swalbe.∇f!(h∇px, h∇py, pressure, dgrad, height)\n        # Slippage\n        Swalbe.slippage!(slipx, slipy, height, velx, vely, sys.δ, sys.μ)\n        # Summation of forces\n        Fx .= h∇px .+ slipx\n        Fy .= h∇py .+ slipy\n    end\n    # New equilibrium\n    Swalbe.equilibrium!(feq, height, velx, vely, vsq)\n    # Collision and streaming of distribution function\n    Swalbe.BGKandStream!(fout, feq, ftemp, Fx, Fy)\n    # Update of macroscopic quantities\n    Swalbe.moments!(height, velx, vely, fout)\n    # Next iteration\nend\n# Check if the mass is constant\nusing Plots\n# Since h = 1 everywhere and the size 100 x 100 the mass has to be 100^2\nplot(mass, xlabel=\"time [Δt]\", ylabel=\"Mass [lbu]\", label=\"flat interface\", ylim=(100^2-0.1, 100^2+0.1))","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In fact this is a particular strength of the lattice Boltzmann method. Under the assumption that no forces are applied the mass is mathematically conserved. Which is shown in the lower plot","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"(Image: flat)","category":"page"},{"location":"tutorials/#Dewetting-of-patterned-a-substrate","page":"Tutorials","title":"Dewetting of patterned a substrate","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Next we take a look at substrates with a wettability gradient and show how to use an image or geometrical shapes to induce directed dewetting. Here we actually reuse the display simulation of the README.md. The idea is to use Youngs equation","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"cos(theta_texteq) = fracgamma_sg - gamma_slgamma ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"where the gamma's are the three interfacial energies and theta_texteq is the equilibrium contact angle to address the wettability of the substrate. Without problems it is possible to discretize theta_texteq similar to the pressure or the film thickness and therefore effectively introduce a wettability gradient nabla theta_texteq neq 0. In the logo simulation what actually happens is that initial perturbations (ϵ * randn()) grow with time, leading to a film rupture and travelling rims. The ruptures are triggered in regions of high contact angle and the rims meet in regions of low contact angle (letters of the logo). There is a lot of theory involved and if you want to read up on it check out the review from Craster&Matar (paywall), especially section 5. Films driven by intermolecular forces.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"But let's start again with some code, first with a triangle with lower wettability in the middle","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Swalbe\n\n# Define the system size and parameters\nsys = Swalbe.SysConst(Lx = 100,     # 100 lattice units in x-direction \n                      Ly = 100,     # 100 lattice units in y-direction\n                      n = 3,        # first disjoining pressure exponent\n                      m = 2,        # second disjoining pressure exponent\n                      Tmax = 1000)  # LBM time loop runs for 1000 iterations\n\n\n# Allocation of distribution functions, macroscopic variables and forces \nfout, ftemp, feq, height, velx, vely, vsq, pressure, dgrad, Fx, Fy, slipx, slipy, h∇px, h∇py = Swalbe.Sys(sys,      # Size \n                                                                                                          \"CPU\",    # Where to run \n                                                                                                          false,    # No fluctuations\n                                                                                                          Float64)  # Num type\n# Random (gaussian) perturbations put on top of a flat interface\nϵ = 0.001\nheight .= 1.0 .+ ϵ .* randn(sys.Lx, sys.Ly)\n# The contact angle field\ntheta = fill(1/6, sys.Lx, sys.Ly)\n# Lower contact angle in the middle of the substrate\nSwalbe.trianglepattern(theta, 1/6, δₐ=-1/18)\n# Compute the first equilibrium distribution function based on the initial conditions \nSwalbe.equilibrium!(ftemp, height, velx, vely, vsq)\n# Difference in total height with time\ndiff_h = []\n# Start of the lattice Boltzmann time loop\nfor t in 1:sys.Tmax\n    # Fill the difference list\n    push!(diff_h, maximum(height) - minimum(height))\n    # Talks with us all t % tdump time sets\n    if t % sys.tdump == 0\n        println(\"Time step $t mass is $(round(sum(height), digits=3))\")\n    end\n    # The pressure computation \n    Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, theta, sys.n, sys.m, sys.hmin, sys.hcrit)\n    # Pressure gradient\n    Swalbe.∇f!(h∇px, h∇py, pressure, dgrad, height)\n    # Slippage\n    Swalbe.slippage!(slipx, slipy, height, velx, vely, sys.δ, sys.μ)\n    # Summation of forces\n    Fx .= -h∇px .- slipx\n    Fy .= -h∇py .- slipy\n    \n    # New equilibrium\n    Swalbe.equilibrium!(feq, height, velx, vely, vsq)\n    # Collision and streaming of distribution function\n    Swalbe.BGKandStream!(fout, feq, ftemp, Fx, Fy)\n    # Update of macroscopic quantities\n    Swalbe.moments!(height, velx, vely, fout)\n    # Next iteration\nend\n# Another library for plotting and to my understanding actually the best you can do\nusing CairoMakie\n# We are interested in the heatmap of the film thickness and the growth rate of the perturbation\nlet\n\tx1 = 1:1:sys.Tmax\n\ty2 = zeros(sys.Tmax)\n\ty2 .= diff_h\n    fig = Figure(resolution = (960,450))\n\t\n    ax1 = Axis(fig, xlabel = \"time [Δt]\", ylabel = \"Δh [lbu]\",xscale = log10, yscale = log10,xgridstyle=:dash, ygridstyle=:dash, xminorticksvisible = true,\n        xminorticks = IntervalsBetween(9), yminorticksvisible = true,\n        yminorticks = IntervalsBetween(9))\n\tleg = lines!(ax1, x1, y2, color = :navy)\n\tax2 = Axis(fig,  aspect = 1, xlabel = \"x [Δx]\", ylabel = \"y [Δx]\")\n    hmap = heatmap!(ax2, height, colormap = :viridis)\n    cbar = Colorbar(fig, hmap, label = \"thickness\", ticksize=15, tickalign = 1, width = 15)\n\tfig[1,1] = ax1\n    fig[1,2] = ax2\n    fig[1,3] = cbar\n    fig\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Fluid is drained into regions of lower contact angle, therefore into in the triangle. The effect is the strongest around the vertices of the triangle. Since in principle this a dewetting instability with a well defined spectrum computable using the surface tension gamma and the disjoining pressure functional Pi(h). The result should look like the plot below ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"(Image: patterned)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Of course you can and should play with the parameters (gamma, delta, h_0, ...) to get a physically correct simulation :wink:.","category":"page"},{"location":"tutorials/#Droplet-spreading-in-1D","page":"Tutorials","title":"Droplet spreading in 1D","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"If a certain amount of liquid is placed on a surface, like a rain drop :droplet: hitting a plant leaf :fourleafclover: we observe a drop sticking to the leaf. The shape of the droplet is actually nature solving Young's law and finds an equilibrium shape which can be described by a simple macroscopic observable, the contact angle theta_texteq. There is of course more to it, for further reading check out Snoeijer & Andreotti We can recast this behavior with a simple and fast simulation.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In contrast to the two examples before we put the whole experiment into a function and just call the function. While this may seem overkill here it is in fact very useful. Instead of writing a script for every experiment, we simply write a function and loop through function arguments. Making it very convenient to perform phase space scans and parameter studies.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Swalbe\n# Simulation that let's a droplet relax towards it's equilibrium contact angle\nfunction run_dropletrelax(\n    sys::Swalbe.SysConst_1D;    # System Constants\n    radius=20,                  # Initial droplet radius\n    θ₀=1/6,                     # Initial contact angle\n    center=(sys.L÷2),           # Position of the center of mass\n    verbose=true,               # Simulation prints output \n    T=Float64                   # Number subtype\n)\n    println(\"Simulating an out of equilibrium droplet\")\n    # Empty list to store the radius evolution\n    diameter = []\n    # Allocation\n    fout, ftemp, feq, height, vel, pressure, dgrad, F, slip, h∇p = Swalbe.Sys(sys, false, T)\n    # Initial condition, see initialvalues.jl, or ?Swalbe.singledroplet\n    Swalbe.singledroplet(height, radius, θ₀, center)\n    # Initial equilibrium, in this case a D1Q3 equilibrium\n    Swalbe.equilibrium!(ftemp, height, vel)\n    # Lattice Boltzmann loop starts\n    for t in 1:sys.Tmax\n        if verbose\n        # Check if the mass conserved\n            if t % sys.tdump == 0\n                mass = 0.0\n                mass = sum(height)\n\n                println(\"Time step $t mass is $(round(mass, digits=3))\")\n            end\n        end\n        # Push the number of lattice sides inside the droplet to the list\n        push!(diameter, length(findall(height .> 0.06)))\n        # Compute film pressure with contact angle \\theta = 1/9\n        Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, 1/9, sys.n, sys.m, sys.hmin, sys.hcrit)\n        # Compute the gradient of the pressure and multiply it with the height\n        Swalbe.∇f!(h∇p, pressure, dgrad, height)\n        # Calculate the substrate friction, velocity boundary condition\n        Swalbe.slippage!(slip, height, vel, sys.δ, sys.μ)\n        # Sum the forces up\n        F .= h∇p .+ slip\n        # New equilibrium\n        Swalbe.equilibrium!(feq, height, vel)\n        # Collide and stream\n        Swalbe.BGKandStream!(fout, feq, ftemp, -F)\n        # Compute the new moments\n        Swalbe.moments!(height, vel, fout)\n    end\n    return height, diameter\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"If we defined the function as above we can use it to run several experiments and test for example Tanners law. The idea of Tanner was that the evolution of the droplets radius during spreading should be captured by a powerlaw R(t) propto t^alpha, with alpha = 110 in this case. There are subtleties to this which you can read up in this very nice paper by Eddi et al.. Swalbe.jl by definition of a numerical solver does not know about real world experiments. That is why we have to find the correct parameters to capture experimental findings (real world physics), in this case we like to observe a powerlaw growth in radius with alpha = 110.  There are two things we could easily change, the surface tension gamma and the velocity boundary or slippage delta.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"# Dictionary to store the results\nresults = Dict()\n# Loop over different slip lengths\nfor slip in [2.0, 1.0, 0.5]\n    # Simulation parameters\n    sys = Swalbe.SysConst_1D(L=2048, γ=0.001, n=3, m=2, δ=slip, Tmax=2000000);\n    # Run the simulation\n    h, d = run_dropletrelax(sys, radius=400, θ₀=1/4)\n    # Store the data in the dict\n    results[slip] = d\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Given the finite slippage we do not observe large deviations from the alpha=110 powerlaw in the long time limit.","category":"page"},{"location":"tutorials/#Further-tutorials","page":"Tutorials","title":"Further tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"More tutorials will follow in the future. I plan to create one for every  paper the method was used for. So be sure to check out the docs every now and then.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The next tutorial will be about switchable substrates.  In this case the wettability can not only addressed locally but also with a time dependency. Here is what happens if the time frequency is high and this happens if we update with a lower frequency.","category":"page"},{"location":"#Swalbe.jl","page":"Home","title":"Swalbe.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A lattice Boltzmann framework to solve thin liquid film problems.","category":"page"},{"location":"#Thin-film-simulations-using-lattice-Boltzmann","page":"Home","title":"Thin film simulations using lattice Boltzmann","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Why is a thin film solver called Swalbe.jl you may ask?","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea is to use the lattice Boltzmann method (LBM) and all its benefits (easy to code, vast amount of literature and scalability) to simulate thin liquid film flows. Instead of reinventing the wheel we make use of a class of lattice Boltzmann models that were build to simulate shallow water problems, see Salmon (not the fish :fish:), Dellar and van Thang et al. (all free to read). Thus the name of the package Shallow WAter Lattice Boltzmann slovEr or Swalbe.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course using a plain shallow water model will not work to simulate thin film dynamics, that is the reason we build our own model :neckbeard:. Now the main difference is that we throw away most of the shallow water parts by assuming they are small as compared to thin film relevant things, e.g. the substrate fluid interaction. The full explanation of the model with some benchmarks can be found in our paper Zitz et al. (the C/C++ OpenACC codebase has not been further developed since the project moved to Julia)","category":"page"},{"location":"#How-to-**get**","page":"Home","title":"How to get","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First of all you need a Julia installation.  Julia is a high level open source programming language and it is as easy to use as python :snake: (my opinion).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia can be downloaded at the projects homepage julialang.org, or clones from the github repo. If you download Julia from the homepage make sure that you use the correct installation for your operating system. Important for CUDA we require Julia version 1.6 or higher, usually the most recent version is also the one you should aim for.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Swalbe.jl is a registered package of the Julia package manager. The only thing you have to do is to add the package to your Julia environment with: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add Swalbe","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course you can as well clone or fork the repo and activate the package inside der REPL. First you need to go the Swalbe directory and open a REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"cd \\Swalbe_folder\njulia","category":"page"},{"location":"","page":"Home","title":"Home","text":"now you can activate the package with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] activate .\n  Activating environment at `local_Swalbe_folder`\n(Swalbe)> ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To see that the package works you can run the test suit with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] test Swalbe","category":"page"},{"location":"","page":"Home","title":"Home","text":"All tests can be found in test folder, but do not expect too many comments. Still especially the simulate.jl file is worth a look.","category":"page"},{"location":"#How-to-**use**","page":"Home","title":"How to use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The idea of Swalbe.jl is to script your thin film simulation, based on a lattice Boltzmann iteration. That is why most core functions can easily be extended, or used out of the box. So how does it work, fist we have to load Swalbe.jl into the REPL or put the following line on top of our script","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add Swalbe         # If not yet added\njulia> using Swalbe","category":"page"},{"location":"","page":"Home","title":"Home","text":"which can take a minute or so, don't be alarmed if it takes more than ten seconds. Alternatively one can use DrWatson (super cool package to manage scientific computing with Julia) and use the @quickactivate :Swalbe macro, have a look at the scripts folder for inspiration.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a picture says more than a thousand words here is a shiny use case of Swalbe.jl ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Images, Colors, Swalbe\n\n\"\"\"\n  dewet_logo(logo_source, kwargs...)\n\nDewetting of a patterned substrate with pattern according to a image file at `logo_source`.\n\"\"\"\nfunction dewet_logo(logo_source;         # png file location\n                    ϵ=1e-3,              # initial perturbation\n                    h₀=1.0,              # initial film thickness\n                    device=\"CPU\",        # simulation on the CPU\n                    slip=3.0,            # slip length, see three phase contact line\n                    Tmax=10000,          # number of lattice Boltzmann iterations\n                    dump=100,            # saving interval   \n                    T=Float64,           # numeric accuracy\n                    verbose=true)        # let's talk         \n\tprintln(\"Starting logo dewetting\")\n\t# Load the image file\n    logo = load(logo_source)\n    # Set up of the simulation constants\n    sys = Swalbe.SysConst(Lx=size(logo)[1], Ly=size(logo)[2], Tmax=Tmax, tdump=dump, δ=slip)\n    # Memory allocation\n    fout, ftemp, feq, height, velx, vely, vsq, pressure, dgrad, Fx, Fy, slipx, slipy, h∇px, h∇py = Swalbe.Sys(sys, device, false, T)\n    # Output\n    fluid = zeros(Tmax÷dump, sys.Lx*sys.Ly) \n    theta = zeros(sys.Lx, sys.Ly)\n    println(\"Reading logo: $(logo_source)\\nand pattern substrate according to it\")\n    # Lower contact angle inside the letters, here the red channel of the image is used\n    theta = T.(2/9 .- 1/18 .* red.(reverse(rot180(logo), dims=2)))\n    if device == \"CPU\"\n        for i in 1:sys.Lx, j in 1:sys.Ly\n            # Initial height configuration\n            height[i,j] = h₀ + ϵ * randn()\n        end\n        th = zeros(size(height))\n        th .= theta \n    elseif device == \"GPU\"\n        h = zeros(size(height))\n        for i in 1:sys.Lx, j in 1:sys.Ly\n            h[i,j] = h₀ + ϵ * randn()\n        end\n        # Lower contact angle inside the letters\n\t\t# Forward it to the GPU\n\t\tth = CUDA.adapt(CuArray, theta)\n        height = CUDA.adapt(CuArray, h)\n    end\n    # Computation of the initial equilibrium\n    Swalbe.equilibrium!(fout, height, velx, vely, vsq)\n    ftemp .= fout\n    # Lattice Boltzmann time loop\n    for t in 1:sys.Tmax\n        if t % sys.tdump == 0\n            mass = 0.0\n            mass = sum(height)\n            deltaH = maximum(height) - minimum(height)\n            # Simulation talks with you\n            if verbose\n                println(\"Time step $t mass is $(round(mass, digits=3)) and δh is $(round(deltaH, digits=3))\")\n            end\n        end\n        # Calculation of the pressure and the pressure gradient\n        Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, th, sys.n, sys.m, sys.hmin, sys.hcrit)\n        Swalbe.∇f!(h∇px, h∇py, pressure, dgrad, height)\n        # Forces are the pressure gradient and the slippage due to substrate liquid boundary conditions\n        Swalbe.slippage!(slipx, slipy, height, velx, vely, sys.δ, sys.μ)\n        Fx .= h∇px .+ slipx\n        Fy .= h∇py .+ slipy\n        # New equilibria\n        Swalbe.equilibrium!(feq, height, velx, vely, vsq)\n        # Single relaxation and streaming\n        Swalbe.BGKandStream!(fout, feq, ftemp, -Fx, -Fy)\n        # New moments\n        Swalbe.moments!(height, velx, vely, fout)\n        # Measurements, in this case only snapshots of simulation's arrays\n        Swalbe.snapshot!(fluid, height, t, dumping = dump)\n    end\n    return fluid\n    # Free the GPU\n    if device == \"GPU\"\n        CUDA.reclaim()\n    end\nend\n# Run the simulation\ndewet_logo(\"path-to-logo\", slip=3.0, Tmax=10000, dump=100, verbose=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here the Images and Colors package allow convenient reading of png or jpg files. To give you an understanding of what happens here we take a look at the different parts. First of we define our simulation as function in this case dewet_logo(). There is one input needed, namely the location of the png or jpg file you want to dewet, in my case I used our institutes logo. Other arguments are keywords that have a default value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next step is to define the system we want to simulate, so mostly allocations and initial conditions as well as substrate patterning","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Load the image file\nlogo = load(logo_source)\n# Set up of the simulation constants\nsys = Swalbe.SysConst(Lx=size(logo)[1], Ly=size(logo)[2], Tmax=Tmax, tdump=dump, δ=slip)\n# Memory allocation\nfout, ftemp, feq, height, velx, vely, vsq, pressure, dgrad, Fx, Fy, slipx, slipy, h∇px, h∇py = Swalbe.Sys(sys, device, false, T)\n# Output\nfluid = zeros(Tmax÷dump, sys.Lx*sys.Ly) \ntheta = zeros(sys.Lx, sys.Ly)\nprintln(\"Reading logo: $(logo_source)\\nand pattern substrate according to it\")\n# Lower contact angle inside the letters, here the red channel of the image is used\ntheta = T.(2/9 .- 1/18 .* red.(reverse(rot180(logo), dims=2)))\nif device == \"CPU\"\n    for i in 1:sys.Lx, j in 1:sys.Ly\n        # Initial height configuration\n        height[i,j] = h₀ + ϵ * randn()\n    end\n    th = zeros(size(height))\n    th .= theta \nelseif device == \"GPU\"\n    h = zeros(size(height))\n    for i in 1:sys.Lx, j in 1:sys.Ly\n        h[i,j] = h₀ + ϵ * randn()\n    end\n    # Lower contact angle inside the letters\n\t# Forward it to the GPU\n\tth = CUDA.adapt(CuArray, theta)\n    height = CUDA.adapt(CuArray, h)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the simulation box (or square to be more precise) is set we compute the first lattice Boltzmann equilibrium Swalbe.equilibrium!(fout, height, velx, vely, vsq). Knowing the initial equilibrium we can enter the lattice Boltzmann time loop. Inside the loop we compute for every time step the forces that are present, here the film pressure (laplacian of the surface and wettability), slippage to regularize the contact line and the pressure gradient","category":"page"},{"location":"","page":"Home","title":"Home","text":"Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, th, sys.n, sys.m, sys.hmin, sys.hcrit)\nSwalbe.∇f!(h∇px, h∇py, pressure, dgrad, height)\nSwalbe.slippage!(slipx, slipy, height, velx, vely, sys.δ, sys.μ)\n# Forces are the pressure gradient and the slippage due to substrate liquid boundary conditions\nFx .= h∇px .+ slipx\nFy .= h∇py .+ slipy","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now that we know the forces we just have to update our distribution functions fout and ftemp (the hot sauce of the lattice Boltzmann method), in this case with a simple single relaxation time collision operator (BGK) and periodic boundary conditions. Last part of the lattice Boltzmann time step is the update of what is called macroscopic quantities (thickness & velocity), or simply the moment calculation (because these are the moments of the distribution mathematically speaking)","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Update the equilibrium\nSwalbe.equilibrium!(feq, height, velx, vely, vsq)\n# Collide and stream\nSwalbe.BGKandStream!(fout, feq, ftemp, -Fx, -Fy)\n# New moments\nSwalbe.moments!(height, velx, vely, fout)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and that's it. Of course to generate data we make snapshots of the film using Swalbe.snapshot!() and return this collection of thicknesses at the end of the simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"What we get is something like this","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Hiern_logo_dewetting)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All of the time steps that were generated during the simulation can be merged together and can be compressed into a movie, see below","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Dewetting_logo)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This example will be further discussed in the Tutorials section.","category":"page"},{"location":"#How-to-**perform-research**","page":"Home","title":"How to perform research","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The numerical approach is quite robust for a lot of thin film simulations. This means in the limit of small Reynolds (Re) and Mach number (Ma) simulations are usually stable. As we employ the long wave approximation to derive the thin film equation we require that contact angle are small.  Numerically the system is stable of up to 90^circ but to be within the theoretical assumptions we suggest to work with contact angles θ ll 1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Things that we had a look at","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sliding droplets\nSurface tension gradients and droplet coalescence\nEquilibrium shapes of droplets on patterned substrates, depending on surface tension.\nRayleigh-Taylor instability\nDewetting thin films\nDewetting of fluctuating thin films\nDewetting on switchable substrates\nActive thin films\nRing-rivulets\nMultilayer films","category":"page"},{"location":"","page":"Home","title":"Home","text":"Things I have not yet looked into","category":"page"},{"location":"","page":"Home","title":"Home","text":"Non-Newtonian fluids\nSurfactants\nParticles\nMulticomponent/Multiphase","category":"page"},{"location":"#Publications","page":"Home","title":"Publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lattice Boltzmann simulations of the dynamics of thin liquid films","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cumulative thesis for the grade Dr.-Ing. of Stefan Zitz. About fifty pages of introduction to thin film dynamics, the shallow water system and numerical methods for thin films. Some discussion on the lattice Boltzmann method followed by a conclusion and four published articles (see below).   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lattice Boltzmann method for thin-liquid-film hydrodynamics","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this Phys. Rev. E publication we introduce the core concepts of Swalbe. We therefore discuss the lattice Boltzmann method for shallow water flows and derive a matching condition with the thin film equation. Based on the derived model we present benchmark simulations and show that numerical results agree well with theoretical predictions, e.g., Cox-Voinov law.     ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lattice Boltzmann simulations of stochastic thin film dewetting","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the second Phys. Rev. E publication we discusses the addition of a stochastic force term as an effective model for the stochastic thin film equation, see Grün et al.. This approach works surprisingly well and was validated against theory. Beyond the validation we showed how a film reacts to both a chemical pattern and thermal fluctuations. Again we were able to justify multiple findings with simple theoretical derivations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Swalbe.jl: A lattice Boltzmann solver for thin film hydrodynamics","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the first two publications we cleaned up the repository and added this documentation as well as test cases.  During this process we became aware about the Journal of Open Source Software which we wholeheartly support.  Scientific software is of value, however, it is often seen as byproduct and meeting the actual rigor requirement for a publication only discussing software is far from trivial.  A JOSS publication was therefore a good place to show that Swalbe.jl is an open source tool and that it has a well definded scientific goal, namely thin liquid film solutions or the approximation of the thin film equation.   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Controlling the dewetting morphologies of thin liquid films by switchable substrates","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this letter in Phys. Rev. Fluids we investigate a dewetting thin film on a \"switchable\" substrate.  The idea is that based on external stimuli, such as light, local surface chemistry can be altered.  We build a toy model that effects the local wettability both in time and space and found a non-dimensional number that explained the morphology changes that we observe and were able to motivate further results with theoretical considerations.  Figure 1 and some videos have rendered from simulation data using blender. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Chemically Reactive Thin Films: Dynamics and Stability","category":"page"},{"location":"","page":"Home","title":"Home","text":"This model was mainly developed by Tilman Richter and deals with active components that locally influences the surface tension.  In contrast to a surfactant model this model allows for both a surface tension increase and decrease based on a parameter. That said this generality made the model somewhat complex and the derivation of eigenmodes is far from trivial.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instabilities of ring-rivulets: Impact of substrate wettability","category":"page"},{"location":"","page":"Home","title":"Home","text":"This paper has been accpeted in April 2025. We study the dynamics of a ring-rivulet which is basically a liquid torus cut in half. This initial condition has several interesting features and it is only a transient state, because it either retracts to single droplet or breaks up and forms multiple droplets. Our work adds to the current understanding of this object by further considering wettability. We show that a wettability gradient can turn a retracting ring-rivulet into one that breaks up and vise versa. ","category":"page"},{"location":"#Preprints:","page":"Home","title":"Preprints:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To coalesce or not to coalesce: Droplets and surface tension gradients\nModeling of thin liquid films with arbitrary many layers","category":"page"},{"location":"#How-to-**support-and-contribute**","page":"Home","title":"How to support and contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First of all leave a star if you like the idea of the project and/or the content of the package. Second you can support the project by actively using it and raising issues. Help is always very welcome, if you want to contribute open a PR or raise an issue with a feature request (and if possible with a way how to include it). Feel free to DM me on Bluesky if you have questions, I try to answer them all timely.","category":"page"}]
}
