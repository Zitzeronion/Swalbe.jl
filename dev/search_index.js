var documenterSearchIndex = {"docs":
[{"location":"functions/#Internal-Functions","page":"Functions","title":"Internal Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = Swalbe","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [Swalbe]\r\nPages = [\"equilibrium.jl\", \"collide.jl\", \"moments.jl\", \"forcing.jl\", \"pressure.jl\", \r\n         \"differences.jl\", \"initialize.jl\", \"initialvalues.jl\", \"measures.jl\", \"simulate.jl\"]","category":"page"},{"location":"functions/#Swalbe.equilibrium!-NTuple{6, Any}","page":"Functions","title":"Swalbe.equilibrium!","text":"Equilibrium!(feq, height,velocityx, velocityy, vsquare, gravity)\n\nCalculation of the equilibrium distribution feq for the shallow water lattice Boltzmann method.\n\nArguments\n\nfeq :: Array{<:Number,3}: Equilibrium distribution function, to be calculated\nheight :: Array{<:Number,2}: The height field h(mathbfxt)\nvelocityx :: Array{<:Number,2}: x-component of the macroscopic velocity\nvelocityy :: Array{<:Number,2}: y-component of the macroscopic velocity\nvsquare :: Array{<:Number,2}: Dummy array that is preallocated to be filled with the square of the velocity vector\ngravity <: Number: Strength of the gravitational acceleration in lattice units\n\nMathematics\n\nThe detailed motivation and derivation can be found in the article of Salmon. Similar to the standard Navier-Stokes approximating lattice Boltzmann methods the equilibrium distribution feq is an expansion to second order in velocity u. If you want it is an slow mode part of the shallow water theory and thus the equilibrium is given as\n\nf_i^texteq = h bigg(1 - frac56g h - frac23u^2bigg)quad i=0 newline    f_i^texteq = w_i h bigg(g h + 3 mathbfc_icdotmathbfu + frac92(mathbfc_icdotmathbfu)^2) + frac32u^2bigg)quad else\n\nwhere g is the gravitational acceleration (in lattice units) and w_i mathbfc_i are the weights and lattice velocities.\n\nIt has been shown that it is possible to get rid of the gravity driven term in the equilibrium distribution, thus\n\nf_i^texteq = h bigg(1 - frac23u^2bigg)quad i=0 newline f_i^texteq = w_i h bigg(3 mathbfc_icdotmathbfu + frac92(mathbfc_icdotmathbfu)^2) + frac32u^2bigg)quad else\n\nthen of course the topography gradient has to be included as a force term.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> feq = zeros(5,5,9); ρ = ones(5,5); ux = fill(0.1,5,5); uy = zeros(5,5);\n\njulia> Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5), 0.1) # Supply dummy u^2 as well.\n\njulia> feq[:,:,1]\n5×5 Matrix{Float64}:\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n 0.91  0.91  0.91  0.91  0.91\n\njulia> Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5)) # Use the dispatch without g.\n\njulia> @test all(feq[:,:,1] .≈ 1 - 2/3 * 0.01)\nTest Passed\n\nReferences\n\nSalmon\nDellar\nPeng et al.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.BGKandStream!-NTuple{6, Any}","page":"Functions","title":"Swalbe.BGKandStream!","text":"BGKandStream!(fout, feq, ftemp, Fx, Fy, τ)\n\nPerforms a BGK collision operation with a WFM forcecorrection and a subsequent streaming of the resulting populations.\n\nArguments\n\nfout :: Array{<:Number,3}: Streamed distribution after the collision processes\nfeq :: Array{<:Number,3}: Equilibrium distribution, computed with equilibrium!\nftemp :: Array{<:Number,3}: Temporary distribution from the time step before, only useful if tau neq 1\nFx :: Array{<:Number,2}: Sum of forces acting on the fluid in x-direction\nFy :: Array{<:Number,2}: Sum of forces acting on the fluid in y-direction\nτ <: Number: Relaxtion time, if not supplied tau = 1 assumed\n\nMathematics\n\nThe lattice Boltzmann equation in its discretized format is relatively simple to write down\n\nf_alpha(mathbfx+mathbfe_alphaDelta t t+Delta t) - f_alpha(mathbfx t) = -frac1tau(f_alpha(mathbfx t) - f^texteq_alpha(mathbfx t)) + Delta t mathcalS_alpha\n\nwhere the collision kernel is approximated with a BKG single relaxation time (SRT) \n\nOmega_alpha = frac1tau(f_alpha(mathbfx t) - f^texteq_alpha(mathbfx t)\n\nand a source term mathcalS which is given by\n\nmathcalS_alpha = frac3 w_alphae_alpha xe_alpha x+e_alpha ye_alpha ymathbfe_alphacdotmathbfF_alpha \n\nThe term e_alpha xe_alpha x+e_alpha ye_alpha y is either zero for the zeroth population, 1 for the first four populations or 2 for the remaining ones.\n\nExamples\n\njulia> using Swalbe\n\njulia> feq = ones(5,5,9); ftemp = zeros(5,5,9); fout = zeros(5,5,9);\n\njulia> feq[1,1,:] .= 2.0 # To check the streaming process \n9-element view(::Array{Float64, 3}, 1, 1, :) with eltype Float64:\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n 2.0\n\njulia> Swalbe.BGKandStream!(fout, feq, ftemp, zeros(5,5), zeros(5,5))\n\njulia> fout[:,:,6] # The value 2 should have moved one down and one to the right!\n5×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  2.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n\n\nReferences\n\nSalmon\nDellar\nPeng et al.\n\nSee also: Swalbe.equilibrium\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.viewdists-Tuple{Any}","page":"Functions","title":"Swalbe.viewdists","text":"viewdists(f)\n\nGenerates a view for all nine populations of a D2Q9 distribution function.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> ftest = reshape(collect(1.0:225.0),5,5,9);\n\njulia> f0, f1, f2, f3, f4, f5, f6, f7, f8 = Swalbe.viewdists(ftest);\n\njulia> @test all(f3 .== ftest[:,:,4])\nTest Passed\n\n\nSee also: Swalbe.BGKandStream\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.viewdists_1D-Tuple{Any}","page":"Functions","title":"Swalbe.viewdists_1D","text":"viewdists_1D(f)\n\nGenerates a view for all three populations of a D1Q3 distribution function.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> ftest = reshape(collect(1.0:30.0),10,3);\n\njulia> f0, f1, f2 = Swalbe.viewdists_1D(ftest);\n\njulia> @test all(f1 .== ftest[:,2])\nTest Passed\n\n\nSee also: Swalbe.BGKandStream\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.moments!-Tuple{Matrix{T} where T, Any, Any, Any}","page":"Functions","title":"Swalbe.moments!","text":"moments!(height, velx, vely, fout)\n\nComputation of the hydrodynamic moments, height and velocity.\n\nMathematics\n\nThe macroscopic quantities such as the height and the velocity are the moments of the distribution function, \n\nh(mathbfxt) = sum_i=0^8 f_i \n\nand \n\nmathbfv(mathbfxt) = frac1hsum_i=0^8 mathbfc_i f_i \n\nExamples\n\njulia> using Swalbe, Test\n\njulia> fout = zeros(5,5,9); fout[:,:,1] .= 1.0; fout[:,:,2] .= 0.1; # Dist with artifical velocity in x\n\njulia> height = zeros(5,5); velx = zeros(5,5); vely = zeros(5,5);\n\njulia> Swalbe.moments!(height,velx,vely,fout)\n\njulia> @test all(height .== 1.1)\nTest Passed\n\njulia> @test all(velx .== 0.1/1.1)\nTest Passed\n\njulia> @test all(vely .== 0.0)\nTest Passed\n\nReferences\n\nKrüger\nSalmon\nZitz, Scagliarini and Harting\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.h∇p!-Tuple{Swalbe.State}","page":"Functions","title":"Swalbe.h∇p!","text":"h∇p!(state)\n\nComputation of the pressure gradient multiplied with the height.\n\nMathematics\n\nThe pressure gradient (nabla p) is the driving force of the standard thin film equation partial_t h = (M(h)nabla p). Our approach however does not solve the thin film equation directly, Instead we have to add the pressure gradient as a force which is given as\n\nF_film = -frac1rho_0 h nabla p_film\n\nwhere the term p_film describes the film pressure \n\np_film = -gamma Delta h - Pi(h) \n\nAs such it is the combination of a laplacian term that minimizes the surface area as well as a interfacial potential between substrate and fluid.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> state = Swalbe.Sys(Swalbe.SysConst(Lx=10, Ly=10), \"CPU\");\n\njulia> state.pressure .= reshape(collect(1:100),10,10);\n\njulia> Swalbe.h∇p!(state)\n\njulia> @test all(state.h∇px[1,:] .== -4.0) # at boundary\nTest Passed\n\njulia> @test all(state.h∇px[2,:] .== 1.0) # inside\nTest Passed\n\n\nReferences\n\nZitz, Scagliarini and Harting\nCraster, Matar\nOron, Davis and Bankoff\n\nSee also: Swalbe.filmpressure!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.inclination!-Tuple{Vector{T} where T, Swalbe.State}","page":"Functions","title":"Swalbe.inclination!","text":"inclination!(α, state)\n\nForce that mimics the effect of an inclined plate.\n\nSimple model to add a body force on the fluid that should mimic the effect of an inclined plate. The model includes a smoothing tanh function to absorb shocks which might occure.\n\nArguments\n\n-α :: Vector: Force vector that both hosts direction of the force as well as strength -state::State: Lattice Boltzmann state of the fluid, here we need the state.Fx, state.Fy fields -t::Int: Time step, used for the smoothing tanh factor -tstart::Int: Time delay at which the tanh becomes positve -tsmooth::Int: Time interval over which the tanh is smeared\n\nMathematics\n\nThis body force is simply force strength time the mass of the fluid or even simpler the height (assuming ρ=1). Thus the force becomes\n\nmathbfF = mathbfalpha h tanhbigg(fract-t_0t_sbigg)\n\nwith t_0 being the time lag at which the tanh changes sign and t_s is width of interval between -1 and 1.\n\nSee also: Swalbe.run_dropletforced\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.slippage!-NTuple{7, Any}","page":"Functions","title":"Swalbe.slippage!","text":"slippage!(slipx, slipy, height, velx, vely, δ, μ)\n\nFluid substrate interaction that effectively mimics a velocity boundary condition at h=0.\n\nArguments\n\nslipx :: Array{<:Number,2}: The x-component of the force due the velocity boundary condition\nslipy :: Array{<:Number,2}: The y-component of the force due the velocity boundary condition\nheight::Array{<:Number,2}: Height field h(mathbfxt)\nvelx::Array{<:Number,2}: x-component of the macroscopic velocity vector\nvely::Array{<:Number,2}: y-component of the macroscopic velocity vector\nδ <: Number: Extrapolation length into the substrate where the no-slip is met\nμ <: Number: Kinematic viscosity of the simulation, dependent on the value of τ\n\nMathematics\n\nWith the velocity boundary condition at the fluid substrate interface we build the second main descriptor between our model and the thin film equation. One well studied assumption is that the fluid velocity vanishes at h(mathbfx) = 0 which is called no-slip condition. In terms of thin film mobility M(h) this means \n\nM(h) = frach^33mu\n\nThis assumption, however, can be relaxed to allow for some slippage with a further parameter δ which determines the slip length. The here presented model matches the thin film equation by modification of the momentum equation of the shallow water model. Therefore the force we add to the momentum equation to compensate for the substrate fluid friction is given as\n\nF_fric = -nu alpha_delta(h)mathbfu\n\nwhere ν is the kinematic viscosity and α \n\nalpha_delta(h) = frac6h2h^2 + 6hdelta +3delta^2\n\nand δ being the slip length, or the distance inside the substrate where the fluids velocity vanishes.\n\nReferences\n\nZitz, Scagliarini and Harting\nMünch, Wagner und Witelski\nOron, Davis and Bankoff\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.thermal!-NTuple{6, Any}","page":"Functions","title":"Swalbe.thermal!","text":"thermal!(fx, fy, height, kᵦT, μ, δ)\n\nComputations of force due to thermal fluctuations.\n\nArguments\n\nfx :: Array{<:Number,2}: x-component of the force due to the fluctuations\nfy :: Array{<:Number,2}: y-component of the force due to the fluctuations\nheight :: Array{<:Number,2}: Height field h(mathbfxt)\nkᵦT <: Number: Strenght of thermal fluctuations in lattice units\nμ <: Number: The kinetic viscosity\nδ <: Number: Slip length, needed to normalize\n\nMathematics\n\nThe classical thin film equation is an equation without thermal noise which is defined as\n\npartial_t h = nablacdot(M(h)nabla p)\n\nClassically thermal excitations are neglected for thin film flows. It is of course possible to introduce for example an envolving surface tension or viscosity but both do not account for e.g. the spectrum of thermal capillary waves. The reason for this short coming is the complex from the thin film equation takes if derived from the Landau-Lifshitz Navier-Stokes equation. One addition term due to the stochastic stress tensor makes it somewhat impossible to solve the eqaution self-consistently. However Grün et al. showed that it is not nessary to use the full stochastic stress tensor, but simple a multiplicative noise term\n\npartial_t h = nablacdotM(h)(nabla p + sigma mathcalN\n\nwhere sigma and mathcalN are a dimensionless temperture and a gaussian white noise. Similar to the pressure gradient the addition of this term is introduced as force in our model\n\nF_fluc = frac1rho_0sqrt2k_BTmualpha_delta(h)mathcalN\n\nwith alpha_delta(h) being the force generated due to substrate slip. \n\nExamples\n\njulia> using Swalbe, Statistics, Test\n\njulia> x = ones(50,50); y = ones(50,50); h = ones(50,50);\n\njulia> Swalbe.thermal!(x, y, h, 0.1, 1/6, 1)\n\njulia> @test mean(x) ≈ 0.0 atol=1e-2\nTest Passed\n\njulia> @test mean(y) ≈ 0.0 atol=1e-2\nTest Passed\n\njulia> @test var(x) ≈ 2*0.1/11 atol=(2*0.1/11)/10 # var = 2kbt*6*μ/slip\nTest Passed\n\n\nReferences\n\nGrün, Mecke and Rauscher\nMecke, Rauscher\nDavidovitch, Moro and Stone\n\nSee also: Swalbe.slippage!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.update_rho!-NTuple{5, Any}","page":"Functions","title":"Swalbe.update_rho!","text":"update_rho()\n\nTime evolution of the active field rho.\n\nTODO: @Tilmann!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.view_four-Tuple{Any}","page":"Functions","title":"Swalbe.view_four","text":"view_four()\n\nSplits a chuck of memory in four equivalent chucks\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.filmpressure!-NTuple{8, Any}","page":"Functions","title":"Swalbe.filmpressure!","text":"filmpressure!(pressure, height, γ, θ, n, m, hmin, hcrit)\n\nCalculation of the capillary pressure which is given by p = - γ²h+ Π(h).\n\nArguments\n\npressure :: Array{Number,2}: Array that store the result of the compuation\nheight :: Array{Number,2}: Height field h(mathbfxt)\nγ <: Number: Forcing strenght due to surface tension\nθ <: Number: Equilibrium contact angle\nn :: Int: Larger power law exponent for Π(h)\nm :: Int: Smaller power law exponent for Π(h)\nhmin <: Number: Parameter of Π(h), in fact Π(hmin) = 0\nhcrit <: Number: Numerical stabilizer for case h(mathbfxt) ll hmin\n\nMathematics\n\nThe capillary pressure p_textcap is the centeral angle to match our model with the thin film equation. It consists of two parts, first being the laplace pressure nabla^2 h and second being the derivative of the disjoining pontential Pi(h)\n\np_textcap = -gamma nabla^2 h + Pi(h)\n\nFor the laplacian term we use the same nine point discretization as in Swlabe.∇²f!. Pi(h) on the other hand is given by \n\nPi(h) = kappa(theta)f(h)\n\nwhere kappa(theta) is simply a measure for the Hamaker constant and given as\n\nkappa(theta) = gamma(1- cos(theta))frac(n-1)(m-1)(n-m)h_textmin\n\nFor f(h) one can use various forms, a very common however is the power law given by \n\nf(h) = biggbigg(frach_textminhbigg)^n - bigg(frach_textminhbigg)^mbigg\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> h = reshape(collect(1.0:25.0),5,5) # A dummy height field\n5×5 Matrix{Float64}:\n 1.0   6.0  11.0  16.0  21.0\n 2.0   7.0  12.0  17.0  22.0\n 3.0   8.0  13.0  18.0  23.0\n 4.0   9.0  14.0  19.0  24.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> pressure = zeros(5,5); θ = 0.0; # Fully wetting substrate\n\njulia> Swalbe.filmpressure!(pressure, h, θ) # default γ = 0.01\n\njulia> result = [30.0 5.0 5.0 5.0 -20;\n                 25.0 0.0 0.0 0.0 -25.0;\n                 25.0 0.0 0.0 0.0 -25.0;\n                 25.0 0.0 0.0 0.0 -25.0;\n                 20.0 -5.0 -5.0 -5.0 -30.0];\n\njulia> for i in eachindex(result)\n           @test result[i] .≈ -100 .* pressure[i] atol=1e-12\n       end\n\nReferences\n\nPeschka et al.\nCraster and Matar\nDerjaguin and Churaev\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.power_broad-Tuple{Float64, Int64}","page":"Functions","title":"Swalbe.power_broad","text":"power_broad(arg, n)\n\nComputes arg to the power n.\n\nActually this is useful because the ^ operator is much slower. Same thing I learned about the pow function in C, * yes it does what you want, but it is slow as fuck *.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> Swalbe.power_broad(3, 3)\n27\n\njulia> Swalbe.power_broad.([2.0 5.0 6.0], 2) # Use the broadcasting operator `.`\n1×3 Matrix{Float64}:\n 4.0  25.0  36.0\n\n\nSee also: filmpressure\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.viewneighbors-Tuple{Any}","page":"Functions","title":"Swalbe.viewneighbors","text":"viewneighbors(f)\n\nGenerates a view for all nine populations of a D2Q9 distribution function.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> ftest = reshape(collect(1.0:5*5*8),5,5,8);\n\njulia> f1, f2, f3, f4, f5, f6, f7, f8 = Swalbe.viewneighbors(ftest);\n\njulia> @test all(f3 .== ftest[:,:,3])\nTest Passed\n\n\nSee also: Swalbe.∇f!, Swalbe.filmpressure!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.viewneighbors_1D-Tuple{Any}","page":"Functions","title":"Swalbe.viewneighbors_1D","text":"viewneighbors_1D(f)\n\nGenerates a view for the two neighbors of a D1Q3 distribution function.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> ftest = reshape(collect(1.0:30),10,3);\n\njulia> f1, f2 = Swalbe.viewneighbors_1D(ftest);\n\njulia> @test all(f2 .== ftest[:,2])\nTest Passed\n\n\nSee also: Swalbe.∇f!, Swalbe.filmpressure!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.∇f!-Tuple{Any, Any, Any}","page":"Functions","title":"Swalbe.∇f!","text":"∇f!(outputx, outputy, f)\n\nGradient calculation with finite differences.\n\nComputes both spatial first derivatives with a nine point stencil from an input f and writes the result to outputx and outputy. Since broadcasting is simple on the GPU we make use of circshift for the neighbors.\n\nMathematics\n\nThe gardient in two dimensions is given as\n\nnabla f = big(fracpartial fpartial x fracpartial fpartial ybig)^T \n\nAgain with the nine point stencil this reduces to \n\nfracpartial fpartial x = frac13 (f_i+1j - f_i-1j) + frac112(f_i+1j+1 - f_i-1j+1 - f_i-1j-1 + f_i+1j-1) \n\nand for the y component we get\n\nfracpartial fpartial y = frac13 (f_ij+1 - f_ij-1) + frac112(f_i+1j+1 + f_i-1j+1 - f_i-1j-1 - f_i+1j-1) \n\nFor the exact derivation feel free to read the reference by Junk and Klar.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> arg = reshape(collect(1.0:25),5,5)\n5×5 Matrix{Float64}:\n 1.0   6.0  11.0  16.0  21.0\n 2.0   7.0  12.0  17.0  22.0\n 3.0   8.0  13.0  18.0  23.0\n 4.0   9.0  14.0  19.0  24.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> resx = zeros(5,5); resy = zeros(5,5); Swalbe.∇f!(resx, resy, arg)\n\njulia> whatXshouldbe = [-1.5 -1.5 -1.5 -1.5 -1.5;\n                         1.0 1.0 1.0 1.0 1.0;\n                         1.0 1.0 1.0 1.0 1.0;\n                         1.0 1.0 1.0 1.0 1.0;\n                        -1.5 -1.5 -1.5 -1.5 -1.5];\n\njulia> for i in eachindex(resx) # Test the x-component\n           @test resx[i] ≈ whatXshouldbe[i] atol=1e-10\n       end\n\njulia> whatYshouldbe = [-7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5;\n                        -7.5 5.0 5.0 5.0 -7.5];\n\njulia> for i in eachindex(resy) # Test the y-component\n           @test resy[i] ≈ whatYshouldbe[i] atol=1e-10\n       end\n\nReferences\n\nJunk & Klar\nSucci et al.\n\nSee also: Swalbe.∇²f!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.∇²f!-Tuple{Any, Any, Any}","page":"Functions","title":"Swalbe.∇²f!","text":"∇²f!(output, f, γ)\n\nFinite difference operator for a second derivative in two dimensions.\n\nComputes the laplacian of an input f times a scalar γ and stores the result in output.\n\nMathematics\n\nThe laplacian operator in two dimensions can be written as\n\nnabla^2 f = fracpartial^2 fpartial x^2 + fracpartial^2 fpartial y\n\nFor the discretization of this operator we use a nine point stencil, such the neighbors as well as the diagonal elements. The concrete derivation can be found in the references below, we just show the final result\n\nnabla^2 f = frac16bigg4(f_i+1j + f_ij+1 + f_i-1j + f_ij-1) newline                 qquadqquad +(f_i+1j+1 + f_i-1j+1 + f_i-1j-1 + f_i+1j-1) newline                 qquadqquad -20f_ijbigg  \n\nwhere we have used Julia conventions, downwards (left) is positive.  The whole expression can be multiplied with a scalar γ if needed.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> arg = reshape(collect(1.0:25),5,5)\n5×5 Matrix{Float64}:\n 1.0   6.0  11.0  16.0  21.0\n 2.0   7.0  12.0  17.0  22.0\n 3.0   8.0  13.0  18.0  23.0\n 4.0   9.0  14.0  19.0  24.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> res = zeros(5,5); Swalbe.∇²f!(res, arg, -1.0)\n\njulia> analytics = [-30.0 -5.0 -5.0 -5.0 20;\n                    -25.0 0.0 0.0 0.0 25.0;\n                    -25.0 0.0 0.0 0.0 25.0;\n                    -25.0 0.0 0.0 0.0 25.0;\n                    -20.0 5.0 5.0 5.0 30.0];\n\njulia> for i in eachindex(analytics)\n           @test analytics[i] ≈ res[i] atol=1e-10\n       end\n\nReferences\n\nJunk & Klar\nSucci et al.\n\nSee also: Swalbe.∇f!\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.CuState","page":"Functions","title":"Swalbe.CuState","text":"CuState\n\nData structure that stores all arrays for a given simulation. Specific for GPU computing using CUDA.jl\n\nArguments\n\nfout :: Array{T,N}: Output distribution function\nftemp :: Array{T,N}: Temporary distribution function, only used if sys.τ ≠ 1\nfeq :: Array{T,N}: Equilibrium distribution function\nheight :: Matrix{T}: Field that stores the scalar height values\nvelx :: Matrix{T}: Field that stores the x-component of the velocity vector\nvely :: Matrix{T}: Field that stores the y-component of the velocity vector\nvsq :: Matrix{T}: Field that stores the velocity squared, used in equilibrium!\npressure :: Matrix{T}: Pressure distribution computed using the filmpressure! function\nFx :: Matrix{T}: Total force acting on the fluid, x-component\nFy :: Matrix{T}: Total force acting on the fluid, y-component\nslipx :: Matrix{T}: Friction force due to substrate slip, x-component\nslipy :: Matrix{T}: Friction force due to substrate slip, y-component\nh∇px :: Matrix{T}: Pressure gradient times the height, x-component\nh∇py :: Matrix{T}: Pressure gradient times the height, y-component\ndgrad :: Array{T,N}: Dummy allocation to store shifted arrays using circshift!\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.State","page":"Functions","title":"Swalbe.State","text":"State{T, N}\n\nData structure that stores all arrays for a given simulation.\n\nArguments\n\nfout :: Array{T,N}: Output distribution function\nftemp :: Array{T,N}: Temporary distribution function, only used if sys.τ ≠ 1\nfeq :: Array{T,N}: Equilibrium distribution function\nheight :: Matrix{T}: Field that stores the scalar height values\nvelx :: Matrix{T}: Field that stores the x-component of the velocity vector\nvely :: Matrix{T}: Field that stores the y-component of the velocity vector\nvsq :: Matrix{T}: Field that stores the velocity squared, used in equilibrium!\npressure :: Matrix{T}: Pressure distribution computed using the filmpressure! function\nFx :: Matrix{T}: Total force acting on the fluid, x-component\nFy :: Matrix{T}: Total force acting on the fluid, y-component\nslipx :: Matrix{T}: Friction force due to substrate slip, x-component\nslipy :: Matrix{T}: Friction force due to substrate slip, y-component\nh∇px :: Matrix{T}: Pressure gradient times the height, x-component\nh∇py :: Matrix{T}: Pressure gradient times the height, y-component\ndgrad :: Array{T,N}: Dummy allocation to store shifted arrays using circshift!\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.State_1D","page":"Functions","title":"Swalbe.State_1D","text":"State_1D{T, N}\n\nData structure that stores all arrays for a given simulation.\n\nArguments\n\nfout :: Matrix{T}: Output distribution function\nftemp :: Matrix{T}: Temporary distribution function, only used if sys.τ ≠ 1\nfeq :: Matrix{T}: Equilibrium distribution function\nheight :: Vector{T}: Field that stores the scalar height values\nvel :: Vector{T}: Field that stores the velocity\npressure :: Vector{T}: Pressure distribution computed using the filmpressure! function\nF :: Vector{T}: Total force acting on the fluid\nslip :: Vector{T}: Friction force due to substrate slip\nh∇p :: Vector{T}: Pressure gradient times the height\ndgrad :: Matrix{T}: Dummy allocation to store shifted arrays using circshift!\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.SysConst","page":"Functions","title":"Swalbe.SysConst","text":"SysConst{T}\n\nStruct that contains all run time constants, e.g. lattice size, surface tension γ and so on.\n\nArguments\n\nLx :: Int: Length of the lattice sides in x-direction\nLy :: Int: Length of the lattice sides in y-direction\nTmax :: Int: Number of lattice Boltzmann time iterations\ntdump :: Int: Dumping interval for e.g. data output\nτ :: T: BGK relaxation rate \ncₛ :: T: Lattice speed of sound, every physical velocity needs to be smaller than this! \nμ :: T: Kinematic fluid viscosity\nδ :: T: Slip length, defines how far the no-slip condition is interpolated into the substrate\nkbt :: T: Thermal energy of the film, works with small values ≈ 10^(-7)\nγ :: T: Surface tension\nn :: Int: Greater exponent of the two used for the powerlaw in the disjoining pressure\nm :: Int: Smaller exponent of the two used for the powerlaw in the disjoining pressure\nhmin :: T: Height value at which the disjoining pressure functional vanishes\nhcrit :: T: Numerical stabilizer for the disjoining pressure term\nθ :: T: Contact angle in multiples of π\ng :: T: gravitational acceleration, usually neglected in thin film simulations\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.SysConst_1D","page":"Functions","title":"Swalbe.SysConst_1D","text":"SysConst_1D{T}\n\nStruct that contains all run time constants, e.g. lattice size, surface tension γ and so on.\n\nArguments\n\nL :: Int: Number of lattice points\nTmax :: Int: Number of lattice Boltzmann time iterations\ntdump :: Int: Dumping interval for e.g. data output\nτ :: T: BGK relaxation rate \ncₛ :: T: Lattice speed of sound, every physical velocity needs to be smaller than this! \nμ :: T: Kinematic fluid viscosity\nδ :: T: Slip length, defines how far the no-slip condition is interpolated into the substrate\nkbt :: T: Thermal energy of the film, works with small values ≈ 10^(-7)\nγ :: T: Surface tension\nn :: Int: Greater exponent of the two used for the powerlaw in the disjoining pressure\nm :: Int: Smaller exponent of the two used for the powerlaw in the disjoining pressure\nhmin :: T: Height value at which the disjoining pressure functional vanishes\nhcrit :: T: Numerical stabilizer for the disjoining pressure term\nθ :: T: Contact angle in multiples of π\ng :: T: gravitational acceleration, usually neglected in thin film simulations\n\n\n\n\n\n","category":"type"},{"location":"functions/#Swalbe.Sys-Tuple{Swalbe.SysConst, String, Bool, Any}","page":"Functions","title":"Swalbe.Sys","text":"Sys(sysc, device, exotic)\n\nMostly allocations of arrays used to run a simulation, but all within one function :)\n\nArguments\n\nsysc :: SysConst: Needed for the lattice dimensions, Lx and Ly\ndevice :: String: Use either CPU for computation of a CPU or GPU for computation on the GPU \nexotic :: Bool: If true thermal fluctuations can be computed and saved to the fthermalx and fthermaly field\nT <: Number: Numerical type, it is strongly suggested to use Float64\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.Sys-Tuple{Swalbe.SysConst_1D, Bool, Any}","page":"Functions","title":"Swalbe.Sys","text":"Sys(sysc, exotic, T)\n\nMostly allocations of arrays used to run a simulation, but all within one function :)\n\nArguments\n\nsysc :: SysConst_1D: Needed for the lattice dimensions, L \nexotic :: Bool: If true thermal fluctuations can be computed and saved to the fthermalx and fthermaly field\nT <: Number: Numerical type, it is strongly suggested to use Float64\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.boxpattern-Tuple{Any, Any}","page":"Functions","title":"Swalbe.boxpattern","text":"boxpattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=20)\n\nDefines a quadratic box around a center with side length side.\n\nArguments\n\nθ::Array{undef,2}: Contact angle map\nθ₀: Default contact angle θ\ncenter::Tuple{Int, Int}: center of the box pattern, default value is (size(θ,1)÷2, size(θ,2)÷2)\nδₐ::Float64: Contact angle contrast with the substrate, default is set to 1/36 ≈ 5 degrees difference\nside::Int: Length of the sides, default is set to 20\n\nExamples\n\njulia> using Swalbe\n\njulia> θ₀ = 1/9;\n\njulia> pattern, polygon = Swalbe.boxpattern(ones(100,100), θ₀);\n\njulia> polygon # Some cool thing we use to create the posize(θ,2)gones, a LazySet\nLazySets.VPolygon{Float64, Vector{Float64}}([[40.0, 40.0], [60.0, 40.0], [60.0, 60.0], [40.0, 60.0]])\n\njulia> pattern[50,50] == pattern[1,1] # In the center there is a different contact angle!\nfalse\n\n\nReferences\n\nReally not much to say here, check out LazySets.jl.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.ellipsepattern-Tuple{Any, Any}","page":"Functions","title":"Swalbe.ellipsepattern","text":"ellipsepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, a=10, b=5)\n\nCreates an ellipse shaped contact angle defect with contact angle mismatch δₐ.\n\nArguments\n\nθ::Array{undef,2}: Contact angle map\nθ₀: Default contact angle θ\ncenter::Tuple{Int, Int}: center of the created pattern, default values is center = (size(θ,1)÷2, size(θ,2)÷2)\nδₐ::Float64: contact angle mismatch between patch and rest of substrate, default is δₐ = 1/36 or 5 degrees\na::Int:: semimajor half ax of the ellipse, default value is a=10\nb::Int:: semiminor half ax of the ellipse, default value is b=5\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> θ₀ = 1/9;\n\njulia> θ, P = Swalbe.ellipsepattern(ones(100,100), θ₀); # per default the center is in the middle!\n\njulia> @test θ[1,1] == θ₀\nTest Passed\n\njulia> @test θ[50,50] == θ₀ + 1/36 # The default increment, is about 5 degrees.\nTest Passed\n\n\nReferences\n\nNothing interesting here.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.randinterface!-Tuple{Any, Any, Any}","page":"Functions","title":"Swalbe.randinterface!","text":"randinterface!(height, h₀, ϵ)\n\nCreates a random height field with average height h₀ and displacement magnitude ϵ.  \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.restart_from_height-Tuple{Any}","page":"Functions","title":"Swalbe.restart_from_height","text":"restart_from_height(data)\n\nRestarts a simulation from already generated height data.\n\nArguments\n\ndata::file: Some file with computed data\nkind::String: File format, .bson or .jld2 are valid options\ntimestep::Int: The time step the height is read from file\nsize::Tuple{Int,Int}: x and y limits of the computational domain\n\njulia> using Swalbe, FileIO, Test\n\njulia> h1 = rand(10,10); h2 = rand(10,10);\n\njulia> f = Dict() # For storage\nDict{Any, Any}()\n\njulia> f[\"h_1\"] = vec(h1); f[\"h_2\"] = vec(h2);\n\njulia> save(\"file.jld2\", f)\n\njulia> h = Swalbe.restart_from_height(\"file.jld2\", timestep=1, size=(10,10));\n\njulia> @test all(h .== h1)\nTest Passed\n\njulia> rm(\"file.jld2\")\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.sinewave1D!-Tuple{Any, Any, Int64, Any, Int64}","page":"Functions","title":"Swalbe.sinewave1D!","text":"sinewave1D!(height, h₀, n, ϵ)\n\nCreates a sine wave like height field with n full waves, average height h₀ and displacement magnitude ϵ.  \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.singledroplet-NTuple{4, Any}","page":"Functions","title":"Swalbe.singledroplet","text":"singledroplet(T, size(θ,1), size(θ,2), radius, θ, center, device=false)\n\nGenerates a fluid configuration of a single droplet in the shape of spherical cap with contact angle θ, sphere radius radius and centered at center.\n\nArguments\n\nheight::Array{undef, 2}: numerical formate, either Float64 or Float32\nradius::AbstractFloat: radius of the underlying sphere from which the spherical cap is cut off\nθ::AbstractFloat: contact angle in multiples of π\ncenter::Tuple{Int,Int}: x and y coordinates of the center of the droplet\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> rad = 50; θ = 1/3;\n\njulia> height = Swalbe.singledroplet(ones(100,100), rad, θ, (50,50));\n\njulia> @test maximum(height) == rad * (1 - cospi(θ)) # Simple geometry\nTest Passed\n\njulia> argmax(height) # Which is constistent with the center!\nCartesianIndex(50, 50)\n\n\nReferences\n\nSee also: \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.trianglepattern-Tuple{Any, Any}","page":"Functions","title":"Swalbe.trianglepattern","text":"trianglepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=60)\n\nGenerates an equilateral triangle centered around center with contact angle contrast δₐ and side length side.\n\nArguments\n\nθ::Array{undef,2}: Contact angle map\nθ₀: Default contact angle θ\ncenter::Tuple(Int, Int): position of the center of the triangle\nδₐ::Float64: contact angle contrast with the rest of the substrate\nside::Int: length of the sides of the equilateral triangle\n\nExamples\n\njulia> using Swalbe\n\njulia> θ, P = Swalbe.trianglepattern(ones(50,50), 1/9, side=20) # Returns a polygon and the contact angle field\n([0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; … ; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111], LazySets.VPolygon{Float64, Vector{Float64}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]]))\n\njulia> P\nLazySets.VPolygon{Float64, Vector{Float64}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]])\n\njulia> θ[25,25]\n0.1388888888888889\n\nReferences\n\nSee also:\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.two_droplets-Tuple{Swalbe.SysConst_1D}","page":"Functions","title":"Swalbe.two_droplets","text":"two_droplets(sys)\n\nGenerates a fluid configuration of a two droplets in the shape of spherical cap with contact angles θ₁, θ₂, sphere radius r₁, r₂ and centers at center.\n\nThis is work in progress, therefore so far it is only available for the lower dimension model.\n\nArguments\n\nr₁::Float64: radius of the first sphere from which the cap is cut of\nr₂::Float64: radius of the second sphere from which the cap is cut of\nθ₁::Float64: contact angle of the first cap in multiples of π\nθ₂::Float64: contact angle of the second cap in multiples of π\ncenter::Tuple{Int,Int}: x coordinates of the centers of the droplets\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> rad = 45; θ = 1/4; sys = Swalbe.SysConst_1D(L=200);\n\njulia> height = Swalbe.two_droplets(sys, r₁=rad, r₂=rad, θ₁=θ, θ₂=θ);\n\njulia> @test maximum(height) ≈ rad * (1 - cospi(θ)) atol=0.01 # Simple geometry\nTest Passed\n\n\nReferences\n\nSee also: \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.fluid_dry!-NTuple{4, Any}","page":"Functions","title":"Swalbe.fluid_dry!","text":"fluid_dry!(fluid, dummy, height, t; hthresh = 0.055)\n\nTracks the location of the thin film as a boolean field.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.snapshot!-Tuple{Any, Any, Any}","page":"Functions","title":"Swalbe.snapshot!","text":"snapshot!(snap, field, t; dumping)\n\nMakes a copy of the current state of an input array in and saves the vectorized values as a column to out.\n\nFunction that fills a preallocated array out with a time series of system snap shots of e.g. the height field h.\n\nArguments\n\nsnap :: Array{Number,2}: Array that stores the snap shots as columns\nfield :: Array{Number,2}: Input argument, e.g. h(mathbfxt)\nt :: Int: The current time step\ndumping :: Int: Sampling frequency\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> h1 = reshape(collect(1:25),5,5); h2 = reshape(collect(5:5:125),5,5);\n\njulia> snapshot = zeros(2, 25);\n\njulia> Swalbe.snapshot!(snapshot,h1,10,dumping=10)\n\njulia> Swalbe.snapshot!(snapshot,h2,20,dumping=10)\n\njulia> @test all(h1 .== reshape(snapshot[1,:],5,5))\nTest Passed\n\njulia> @test all(h2 .== reshape(snapshot[2,:],5,5))\nTest Passed\n\n\nReferences\n\nSee also: The scripts folder \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.surfacearea!-Tuple{Any, Any, Any, Float64, Any, Any, Any, Any, Any}","page":"Functions","title":"Swalbe.surfacearea!","text":"surfacearea!(area_lv, red_energy, height, θ, ∇hx, ∇hy, dgrad, surface,)\n\nMeasures the surface area of the liquid vapor interface and the reduced surface energy.\n\nArguments\n\narea_lv :: Vector{Float64}: array to store the computed liquid vapor area\nred_energy :: Vector{Float64}: array the stores the computed reduced surface energy \nheight :: Matrix{Float64}: current height configuration\nθ :: Matrix{Float64}: contact angle field distribution\n∇hx :: Matrix{Float64}: height gradient x-component \n∇hy :: Matrix{Float64}: height gradient y-component\ndgrad :: Array{Float64,3}: dummy array to store derivatives \nsurface :: Matrix{Float64}: array that computes locally the liquid vapor surface area \nt :: Int: current time step\nhthresh :: Float64: height threshold below which the substrate is considered dry\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.t0-Tuple{}","page":"Functions","title":"Swalbe.t0","text":"t0(;hᵦ=0.07, γ=0.01, μ=1/6, θ=1/6)\n\nComputes a characteristic time scale for an spinodally dewetting film.\n\nArguments\n\nhᵦ :: Float64: height at which the disjoining pressure vanishes\nγ :: Float64: surface tension value\nμ :: Float64: kinematic viscosity, same as dynamic for ρ=1\nθ :: Float64: highest contact angle given as radiant, e.g. θ=π/9 for 20 degrees\n\ne\n\nMathematics\n\nExamples\n\njulia> using Swalbe, Statistics, Test\n\njulia> x = ones(50,50); y = ones(50,50); h = ones(50,50);\n\njulia> Swalbe.thermal!(x, y, h, 0.1, 1/6, 1)\n\njulia> @test mean(x) ≈ 0.0 atol=1e-2\nTest Passed\n\njulia> @test mean(y) ≈ 0.0 atol=1e-2\nTest Passed\n\njulia> @test var(x) ≈ 2*0.1/11 atol=(2*0.1/11)/10 # var = 2kbt*6*μ/slip\nTest Passed\n\n\nReferences\n\nMecke, Rauscher\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.wetted!-NTuple{4, Any}","page":"Functions","title":"Swalbe.wetted!","text":"wetted!(area_size, drop_pos, maxheight, height, t; hthresh = 0.055)\n\nMeasures the wetted area and maximal height of the film at time step t. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.∇f_simple!-NTuple{4, Any}","page":"Functions","title":"Swalbe.∇f_simple!","text":"∇f_simple!(outputx, outputy, f, dgrad)\n\nSimple gradient calculation for the differential surface area.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_dropletforced-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_dropletforced","text":"run_dropletforced()\n\nSimulates an droplet on a patterned substrate\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_dropletpatterned-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_dropletpatterned","text":"run_dropletpatterned()\n\nSimulates an droplet on a patterned substrate\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_dropletrelax-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_dropletrelax","text":"run_dropletrelax()\n\nSimulates an out of equilibrium droplet\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_flat-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_flat","text":"run_flat(Sys::SysConst, device::String)\n\nPerforms a simulation of an flat interface without forces.\n\nArguments\n\nverbos :: Bool: Enables consol output\nT :: AbstractFloat: Precision of output, default Float64\n\nTheory\n\nNothing at all should happen. As the initial state is falt and no force is applied the fluid has no way to flow. The equality h(mathbfx0) = h(mathbfxinfty) should be satisfied for arbitrary many time steps.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> sys = Swalbe.SysConst(Lx=100, Ly=100, Tmax=5000);\n\njulia> h = Swalbe.run_flat(sys, \"CPU\", verbos=false);\n\njulia> @test all(h.height .== 1.0) # Check if all height values are identical to 1.0 (initial condition)\nTest passed\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_random-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_random","text":"run_random(sys::SysConst, device::String)\n\nSimulation of an random undulated interface\n\nArguments\n\nh₀ :: Float : Average initial height\nϵ :: Float : Amplitude of the flucutation\nverbos :: Bool: Enables consol output\nT :: AbstractFloat: Precision of output, default Float64\n\nTheory\n\nInitial randomly perturbed fluid surface. Unstable wavemodes should grow while wavemodes larger q₀ should be damped out. Measuring this is on the TODO list.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> sys = Swalbe.SysConst(Lx=100, Ly=100, Tmax=5000);\n\njulia> Swalbe.randinterface!(height, h₀, ϵ)\n\njulia> h = Swalbe.run_random(sys, \"CPU\", h₀=10, ϵ=0.1, verbos=false);\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.run_rayleightaylor-Tuple{Swalbe.SysConst, String}","page":"Functions","title":"Swalbe.run_rayleightaylor","text":"run_rayleightaylor(sys::SysConst, device::String)\n\nSimulation of an random undulated interface and a gravitanional pull.\n\nArguments\n\nkx :: Int : wavemode in x-direction, kx=18 -> 18 sine waves fitting into the domain\nky :: Int : wavemode in y-direction\nh₀ :: Float : Average initial height\nϵ :: Float : Amplitude of the flucutation\nverbos :: Bool: Enables consol output\nT :: AbstractFloat: Precision of output, default Float64\n\nTheory\n\nInitial randomly perturbed fluid surface hanging from a substrate. Here we have an interplay between gravity and surface tension. The critical wavemode can be computed according to  q_0 = Measuring this is on the TODO list.\n\nExamples\n\njulia> using Swalbe, Test\n\njulia> sys = Swalbe.SysConst(Lx=100, Ly=100, Tmax=5000);\n\njulia> Swalbe.randinterface!(height, h₀, ϵ)\n\njulia> h = Swalbe.run_random(sys, \"CPU\", h₀=10, ϵ=0.1, verbos=false);\n\n\n\n\n\n","category":"method"},{"location":"functions/#Swalbe.time_loop-Tuple{Swalbe.SysConst, Swalbe.State}","page":"Functions","title":"Swalbe.time_loop","text":"time_loop(sys, state)\n\nTime stepping procedure for the lattice Boltzmann state state given parameters sys\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Swalbe.jl is software that simulates the dynamics of a thin liquid film. At it's core is the lattice Boltzmann method (LBM) a mesoscale method that works based on particle distribtuion functions f_i(mathbfxt). To get a better understandig of both the LBM and the package we supply instructive simulations and discuss the content of the code.","category":"page"},{"location":"tutorials/#Constant-interface","page":"Tutorials","title":"Constant interface","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"A nice and easy way to check the consistency of a fluid mechanics solver is to prob the mass or density. Per continuity equation partial_trho + nablacdotmathbfj = 0, we require that the local density rho can only change if there is a flux mathbfj (okay a divergence of a flux).  In case of vanishing or constant flux nablacdotmathbfj = 0 the density has to be time independent and therefore partial_t rho = 0. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Thin film flows can be described with the same kind of equation","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"partial_t h(mathbfxt) + nablaleft(M(h)nabla p(mathbfxt)right) = 0 ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The local height can only change with time if some pressure gradient ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Having a vanshing pressure gradient the height h(mathbfxt) have to be constant independent of time. To check this we put together a small sample simulation that probes this.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Swalbe # import the package\r\n\r\n# Define the system size and parameters\r\nsys = Swalbe.SysConst(Lx = 100,     # 100 lattice units in x-direction \r\n                      Ly = 100,     # 100 lattice units in y-direction\r\n                      Tmax = 1000)  # LBM time loop runs for 1000 iterations\r\n\r\n\r\n# Allocation of distribution functions, macroscopic variables and forces \r\nfout, ftemp, feq, height, velx, vely, vsq, pressure, dgrad, Fx, Fy, slipx, slipy, h∇px, h∇py = Swalbe.Sys(sys,      # Size \r\n                                                                                                          \"CPU\",    # Where to run \r\n                                                                                                          false,    # No fluctuations  \r\n                                                                                                          Float64)  # Num type\r\n# Constant film thickness, or flat interface\r\nheight .= 1.0\r\n# Compute the first equilibrium distribtuion function based on the initial conditions \r\nSwalbe.equilibrium!(ftemp, height, velx, vely, vsq)\r\n# Empty list to measure the total mass over time\r\nmass = []\r\n# To add the forcing due to a pressure gradient set true\r\npressure_gradient = false\r\n# Start of the lattice Boltzmann time loop\r\nfor t in 1:sys.Tmax\r\n    # Fill the list \r\n    push!(mass,sum(height))\r\n    # Talks with us all t % tdump time sets\r\n    if t % sys.tdump == 0\r\n        println(\"Time step $t mass is $(round(sum(height), digits=3))\")\r\n    end\r\n    if pressure_gradient\r\n        # The pressure computation \r\n        Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, 1/9, sys.n, sys.m, sys.hmin, sys.hcrit)\r\n        # Pressure gradient\r\n        Swalbe.∇f!(h∇px, h∇py, pressure, dgrad, height)\r\n        # Slippage\r\n        Swalbe.slippage!(slipx, slipy, height, velx, vely, sys.δ, sys.μ)\r\n        # Summation of forces\r\n        Fx .= h∇px .+ slipx\r\n        Fy .= h∇py .+ slipy\r\n    end\r\n    # New equilibrium\r\n    Swalbe.equilibrium!(feq, height, velx, vely, vsq)\r\n    # Collision and streaming of distribution function\r\n    Swalbe.BGKandStream!(fout, feq, ftemp, Fx, Fy)\r\n    # Update of macroscopic quantities\r\n    Swalbe.moments!(height, velx, vely, fout)\r\n    # Next iteration\r\nend\r\n# Check if the mass is constant\r\nusing Plots\r\n# Since h = 1 everywhere and the size 100 x 100 the mass has to be 100^2\r\nplot(mass, xlabel=\"time [Δt]\", ylabel=\"Mass [lbu]\", label=\"flat interface\", ylim=(100^2-0.1, 100^2+0.1))","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In fact this is a particular strength of the lattice Boltzmann method. Under the assumption that no forces are applied the mass is mathematically conserved. Which is shown in the lower plot","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"(Image: flat)","category":"page"},{"location":"tutorials/#Dewetting-of-patterned-a-substrate","page":"Tutorials","title":"Dewetting of patterned a substrate","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Next we take a look at substrates with a wettability gradient and show how to use an image or geometrical shapes to induce directed dewetting. Here we actually reuse the display simulation of the README.md. The idea is to use Youngs equation","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"cos(theta_texteq) = fracgamma_sg - gamma_slgamma ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"where the gamma's are the three interfacial energies and theta_texteq is the equilibrium contact angle to address the wettability of the substrate. Without problems it is possible to discretize theta_texteq similar to the pressure or the film thickness and therefore effectively introduce a wettability gradient nabla theta_texteq neq 0. In the logo simulation what actually happens is that initial perturbations (ϵ * randn()) grow with time, leading to a film rupture and travelling rims. The ruptures are triggered in regions of high contact angle and the rims meet in regions of low contact angle (letters of the logo). There is a lot of theory involved and if you want to read up on it check out the review from Craster&Matar (paywall), especially section 5. Films driven by intermolecular forces.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"But let's start again with some code, first with a triangle with lower wettability in the middle","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Swalbe\r\n\r\n# Define the system size and parameters\r\nsys = Swalbe.SysConst(Lx = 100,     # 100 lattice units in x-direction \r\n                      Ly = 100,     # 100 lattice units in y-direction\r\n                      n = 3,        # first disjoining pressure exponent\r\n                      m = 2,        # second disjoining pressure exponent\r\n                      Tmax = 1000)  # LBM time loop runs for 1000 iterations\r\n\r\n\r\n# Allocation of distribution functions, macroscopic variables and forces \r\nfout, ftemp, feq, height, velx, vely, vsq, pressure, dgrad, Fx, Fy, slipx, slipy, h∇px, h∇py = Swalbe.Sys(sys,      # Size \r\n                                                                                                          \"CPU\",    # Where to run \r\n                                                                                                          false,    # No fluctuations\r\n                                                                                                          Float64)  # Num type\r\n# Random (gaussian) perturbations put on top of a flat interface\r\nϵ = 0.001\r\nheight .= 1.0 .+ ϵ .* randn(sys.Lx, sys.Ly)\r\n# The contact angle field\r\ntheta = fill(1/6, sys.Lx, sys.Ly)\r\n# Lower contact angle in the middle of the substrate\r\nSwalbe.trianglepattern(theta, 1/6, δₐ=-1/18)\r\n# Compute the first equilibrium distribution function based on the initial conditions \r\nSwalbe.equilibrium!(ftemp, height, velx, vely, vsq)\r\n# Difference in total height with time\r\ndiff_h = []\r\n# Start of the lattice Boltzmann time loop\r\nfor t in 1:sys.Tmax\r\n    # Fill the difference list\r\n    push!(diff_h, maximum(height) - minimum(height))\r\n    # Talks with us all t % tdump time sets\r\n    if t % sys.tdump == 0\r\n        println(\"Time step $t mass is $(round(sum(height), digits=3))\")\r\n    end\r\n    # The pressure computation \r\n    Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, theta, sys.n, sys.m, sys.hmin, sys.hcrit)\r\n    # Pressure gradient\r\n    Swalbe.∇f!(h∇px, h∇py, pressure, dgrad, height)\r\n    # Slippage\r\n    Swalbe.slippage!(slipx, slipy, height, velx, vely, sys.δ, sys.μ)\r\n    # Summation of forces\r\n    Fx .= -h∇px .- slipx\r\n    Fy .= -h∇py .- slipy\r\n    \r\n    # New equilibrium\r\n    Swalbe.equilibrium!(feq, height, velx, vely, vsq)\r\n    # Collision and streaming of distribution function\r\n    Swalbe.BGKandStream!(fout, feq, ftemp, Fx, Fy)\r\n    # Update of macroscopic quantities\r\n    Swalbe.moments!(height, velx, vely, fout)\r\n    # Next iteration\r\nend\r\n# Another library for plotting and to my understanding actually the best you can do\r\nusing CairoMakie\r\n# We are interested in the heatmap of the film thickness and the growth rate of the perturbation\r\nlet\r\n\tx1 = 1:1:sys.Tmax\r\n\ty2 = zeros(sys.Tmax)\r\n\ty2 .= diff_h\r\n    fig = Figure(resolution = (960,450))\r\n\t\r\n    ax1 = Axis(fig, xlabel = \"time [Δt]\", ylabel = \"Δh [lbu]\",xscale = log10, yscale = log10,xgridstyle=:dash, ygridstyle=:dash, xminorticksvisible = true,\r\n        xminorticks = IntervalsBetween(9), yminorticksvisible = true,\r\n        yminorticks = IntervalsBetween(9))\r\n\tleg = lines!(ax1, x1, y2, color = :navy)\r\n\tax2 = Axis(fig,  aspect = 1, xlabel = \"x [Δx]\", ylabel = \"y [Δx]\")\r\n    hmap = heatmap!(ax2, height, colormap = :viridis)\r\n    cbar = Colorbar(fig, hmap, label = \"thickness\", ticksize=15, tickalign = 1, width = 15)\r\n\tfig[1,1] = ax1\r\n    fig[1,2] = ax2\r\n    fig[1,3] = cbar\r\n    fig\r\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Fluid is drained into regions of lower contact angle, therefore into in the triangle. The effect is the strongest around the vertices of the triangle. Since in principle this a dewetting instability with a well defined spectrum computable using the surface tension gamma and the disjoining pressure functional Pi(h). The result should look like the plot below ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"(Image: patterned)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Of course you can and should play with the parameters (gamma, delta, h_0, ...) to get a physically correct simulation :wink:.","category":"page"},{"location":"tutorials/#Droplet-spreading-in-1D","page":"Tutorials","title":"Droplet spreading in 1D","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"If a certain amount of liquid is placed on a surface, like a rain drop :droplet: hitting a plant leaf :fourleafclover: we observe a drop sticking to the leaf. The shape of the droplet is actually nature solving Young's law and finds an equilibrium shape which can be described by a simple macroscopic observable, the contact angle theta_texteq. There is of course more to it, for further reading check out Snoeijer & Andreotti We can recast this behavior with a simple and fast simulation.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In contrast to the two examples before we put the whole experiment into a function and just call the function. While this may seem overkill here it is in fact very useful. Instead of writing a script for every experiment, we simply write a function and loop through function arguments. Making it very convenient to perform phase space scans and parameter studies.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Swalbe\r\n# Simulation that let's a droplet relax towards it's equilibrium contact angle\r\nfunction run_dropletrelax(\r\n    sys::Swalbe.SysConst_1D;    # System Constants\r\n    radius=20,                  # Initial droplet radius\r\n    θ₀=1/6,                     # Initial contact angle\r\n    center=(sys.L÷2),           # Position of the center of mass\r\n    verbose=true,               # Simulation prints output \r\n    T=Float64                   # Number subtype\r\n)\r\n    println(\"Simulating an out of equilibrium droplet\")\r\n    # Empty list to store the radius evolution\r\n    diameter = []\r\n    # Allocation\r\n    fout, ftemp, feq, height, vel, pressure, dgrad, F, slip, h∇p = Swalbe.Sys(sys, false, T)\r\n    # Initial condition, see initialvalues.jl, or ?Swalbe.singledroplet\r\n    Swalbe.singledroplet(height, radius, θ₀, center)\r\n    # Initial equilibrium, in this case a D1Q3 equilibrium\r\n    Swalbe.equilibrium!(ftemp, height, vel)\r\n    # Lattice Boltzmann loop starts\r\n    for t in 1:sys.Tmax\r\n        if verbose\r\n        # Check if the mass conserved\r\n            if t % sys.tdump == 0\r\n                mass = 0.0\r\n                mass = sum(height)\r\n\r\n                println(\"Time step $t mass is $(round(mass, digits=3))\")\r\n            end\r\n        end\r\n        # Push the number of lattice sides inside the droplet to the list\r\n        push!(diameter, length(findall(height .> 0.06)))\r\n        # Compute film pressure with contact angle \\theta = 1/9\r\n        Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, 1/9, sys.n, sys.m, sys.hmin, sys.hcrit)\r\n        # Compute the gradient of the pressure and multiply it with the height\r\n        Swalbe.∇f!(h∇p, pressure, dgrad, height)\r\n        # Calculate the substrate friction, velocity boundary condition\r\n        Swalbe.slippage!(slip, height, vel, sys.δ, sys.μ)\r\n        # Sum the forces up\r\n        F .= h∇p .+ slip\r\n        # New equilibrium\r\n        Swalbe.equilibrium!(feq, height, vel)\r\n        # Collide and stream\r\n        Swalbe.BGKandStream!(fout, feq, ftemp, -F)\r\n        # Compute the new moments\r\n        Swalbe.moments!(height, vel, fout)\r\n    end\r\n    return height, diameter\r\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"If we defined the function as above we can use it to run several experiments and test for example Tanners law. The idea of Tanner was that the evolution of the droplets radius during spreading should be captured by a powerlaw R(t) propto t^alpha, with alpha = 110 in this case. There are subtleties to this which you can read up in this very nice paper by Eddi et al.. Swalbe.jl by definition of a numerical solver does not know about real world experiments. That is why we have to find the correct parameters to capture experimental findings (real world physics), in this case we like to observe a powerlaw growth in radius with alpha = 110.  There are two things we could easily change, the surface tension gamma and the velocity boundary or slippage delta.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"# Dictionary to store the results\r\nresults = Dict()\r\n# Loop over different slip lengths\r\nfor slip in [2.0, 1.0, 0.5]\r\n    # Simulation parameters\r\n    sys = Swalbe.SysConst_1D(L=2048, γ=0.001, n=3, m=2, δ=slip, Tmax=2000000);\r\n    # Run the simulation\r\n    h, d = run_dropletrelax(sys, radius=400, θ₀=1/4)\r\n    # Store the data in the dict\r\n    results[slip] = d\r\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Given the finite slippage we do not observe large deviations from the alpha=110 powerlaw in the long time limit.","category":"page"},{"location":"tutorials/#Further-tutorials","page":"Tutorials","title":"Further tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"More tutorials will follow in the future. I plan to create one for every  paper the method was used for. So be sure to check out the docs every now and then.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The next tutorial will be about switchable substrates.  In this case the wettability can not only addressed locally but also with a time dependency. Here is what happens if the time frequency is high and this happens if we update with a lower frequency.","category":"page"},{"location":"#Swalbe.jl","page":"Home","title":"Swalbe.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A lattice Boltzmann framework to solve thin liquid film problems.","category":"page"},{"location":"#Thin-film-simulations-using-lattice-Boltzmann","page":"Home","title":"Thin film simulations using lattice Boltzmann","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Why is a thin film solver called Swalbe.jl you may ask?","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea is to use the lattice Boltzmann method (LBM) and all its benefits (easy to code, vast amount of literature and scalability) to simulate thin liquid film flows. Instead of reinventing the wheel we make use of a class of lattice Boltzmann models that were build to simulate shallow water problems, see Salmon (not the fish :fish:), Dellar and van Thang et al. (all free to read). Thus the name of the package Shallow WAter Lattice Boltzmann slovEr or Swalbe.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course using a plain shallow water model will not work to simulate thin film dynamics, that is the reason we build our own model :neckbeard:. Now the main difference is that we throw away most of the shallow water parts by assuming they are small as compared to thin film relevant things, e.g. the substrate fluid interaction. The full explanation of the model with some benchmarks can be found in our paper Zitz et al. (the C/C++ OpenACC codebase has not been further developed since the project moved to Julia)","category":"page"},{"location":"#How-to-**get**","page":"Home","title":"How to get","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First of all you need a Julia installation.  Julia is a high level open source programming language and it is as easy to use as python :snake: (my opinion).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia can be downloaded at the projects homepage julialang.org, or clones from the github repo. If you download Julia from the homepage make sure that you use the correct installation for your operating system. Important for CUDA we require Julia version 1.6 or higher, usually the most recent version is also the one you should aim for.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Swalbe.jl is a registered package of the Julia package manager. The only thing you have to do is to add the package to your Julia environment with: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add Swalbe","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course you can as well clone or fork the repo and activate the package inside der REPL. First you need to go the Swalbe directory and open a REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"cd \\Swalbe_folder\njulia","category":"page"},{"location":"","page":"Home","title":"Home","text":"now you can activate the package with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] activate .\n  Activating environment at `local_Swalbe_folder`\n(Swalbe)> ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To see that the package works you can run the test suit with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] test Swalbe","category":"page"},{"location":"","page":"Home","title":"Home","text":"All tests can be found in test folder, but do not expect too many comments. Still especially the simulate.jl file is worth a look.","category":"page"},{"location":"#How-to-**use**","page":"Home","title":"How to use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The idea of Swalbe.jl is to script your thin film simulation, based on a lattice Boltzmann iteration. That is why most core functions can easily be extended, or used out of the box. So how does it work, fist we have to load Swalbe.jl into the REPL or put the following line on top of our script","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add Swalbe         # If not yet added\njulia> using Swalbe","category":"page"},{"location":"","page":"Home","title":"Home","text":"which can take a minute or so, don't be alarmed if it takes more than ten seconds. Alternatively one can use DrWatson (super cool package to manage scientific computing with Julia) and use the @quickactivate :Swalbe macro.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a picture says more than a thousand words here is a shiny use case of Swalbe.jl ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Images, Colors, Swalbe\n\n\"\"\"\n  dewet_logo(logo_source, kwargs...)\n\nDewetting of a patterned substrate with pattern according to a image file at `logo_source`.\n\"\"\"\nfunction dewet_logo(logo_source;         # png file location\n                    ϵ=1e-3,              # initial perturbation\n                    h₀=1.0,              # initial film thickness\n                    device=\"CPU\",        # simulation on the CPU\n                    slip=3.0,            # slip length, see three phase contact line\n                    Tmax=10000,          # number of lattice Boltzmann iterations\n                    dump=100,            # saving interval   \n                    T=Float64,           # numeric accuracy\n                    verbose=true)        # let's talk         \n\tprintln(\"Starting logo dewetting\")\n\t# Load the image file\n    logo = load(logo_source)\n    # Set up of the simulation constants\n    sys = Swalbe.SysConst(Lx=size(logo)[1], Ly=size(logo)[2], Tmax=Tmax, tdump=dump, δ=slip)\n    # Memory allocation\n    fout, ftemp, feq, height, velx, vely, vsq, pressure, dgrad, Fx, Fy, slipx, slipy, h∇px, h∇py = Swalbe.Sys(sys, device, false, T)\n    # Output\n    fluid = zeros(Tmax÷dump, sys.Lx*sys.Ly) \n    theta = zeros(sys.Lx, sys.Ly)\n    println(\"Reading logo: $(logo_source)\\nand pattern substrate according to it\")\n    # Lower contact angle inside the letters, here the red channel of the image is used\n    theta = T.(2/9 .- 1/18 .* red.(reverse(rot180(logo), dims=2)))\n    if device == \"CPU\"\n        for i in 1:sys.Lx, j in 1:sys.Ly\n            # Initial height configuration\n            height[i,j] = h₀ + ϵ * randn()\n        end\n        th = zeros(size(height))\n        th .= theta \n    elseif device == \"GPU\"\n        h = zeros(size(height))\n        for i in 1:sys.Lx, j in 1:sys.Ly\n            h[i,j] = h₀ + ϵ * randn()\n        end\n        # Lower contact angle inside the letters\n\t\t# Forward it to the GPU\n\t\tth = CUDA.adapt(CuArray, theta)\n        height = CUDA.adapt(CuArray, h)\n    end\n    # Computation of the initial equilibrium\n    Swalbe.equilibrium!(fout, height, velx, vely, vsq)\n    ftemp .= fout\n    # Lattice Boltzmann time loop\n    for t in 1:sys.Tmax\n        if t % sys.tdump == 0\n            mass = 0.0\n            mass = sum(height)\n            deltaH = maximum(height) - minimum(height)\n            # Simulation talks with you\n            if verbose\n                println(\"Time step $t mass is $(round(mass, digits=3)) and δh is $(round(deltaH, digits=3))\")\n            end\n        end\n        # Calculation of the pressure and the pressure gradient\n        Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, th, sys.n, sys.m, sys.hmin, sys.hcrit)\n        Swalbe.∇f!(h∇px, h∇py, pressure, dgrad, height)\n        # Forces are the pressure gradient and the slippage due to substrate liquid boundary conditions\n        Swalbe.slippage!(slipx, slipy, height, velx, vely, sys.δ, sys.μ)\n        Fx .= h∇px .+ slipx\n        Fy .= h∇py .+ slipy\n        # New equilibria\n        Swalbe.equilibrium!(feq, height, velx, vely, vsq)\n        # Single relaxation and streaming\n        Swalbe.BGKandStream!(fout, feq, ftemp, -Fx, -Fy)\n        # New moments\n        Swalbe.moments!(height, velx, vely, fout)\n        # Measurements, in this case only snapshots of simulation's arrays\n        Swalbe.snapshot!(fluid, height, t, dumping = dump)\n    end\n    return fluid\n    # Free the GPU\n    if device == \"GPU\"\n        CUDA.reclaim()\n    end\nend\n# Run the simulation\ndewet_logo(\"path-to-logo\", slip=3.0, Tmax=10000, dump=100, verbose=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here the Images and Colors package allow convenient reading of png or jpg files. To give you an understanding of what happens here we take a look at the different parts. First of we define our simulation as function in this case dewet_logo(). There is one input needed, namely the location of the png or jpg file you want to dewet, in my case I used our institutes logo. Other arguments are keywords that have a default value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next step is to define the system we want to simulate, so mostly allocations and initial conditions as well as substrate patterning","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Load the image file\nlogo = load(logo_source)\n# Set up of the simulation constants\nsys = Swalbe.SysConst(Lx=size(logo)[1], Ly=size(logo)[2], Tmax=Tmax, tdump=dump, δ=slip)\n# Memory allocation\nfout, ftemp, feq, height, velx, vely, vsq, pressure, dgrad, Fx, Fy, slipx, slipy, h∇px, h∇py = Swalbe.Sys(sys, device, false, T)\n# Output\nfluid = zeros(Tmax÷dump, sys.Lx*sys.Ly) \ntheta = zeros(sys.Lx, sys.Ly)\nprintln(\"Reading logo: $(logo_source)\\nand pattern substrate according to it\")\n# Lower contact angle inside the letters, here the red channel of the image is used\ntheta = T.(2/9 .- 1/18 .* red.(reverse(rot180(logo), dims=2)))\nif device == \"CPU\"\n    for i in 1:sys.Lx, j in 1:sys.Ly\n        # Initial height configuration\n        height[i,j] = h₀ + ϵ * randn()\n    end\n    th = zeros(size(height))\n    th .= theta \nelseif device == \"GPU\"\n    h = zeros(size(height))\n    for i in 1:sys.Lx, j in 1:sys.Ly\n        h[i,j] = h₀ + ϵ * randn()\n    end\n    # Lower contact angle inside the letters\n\t# Forward it to the GPU\n\tth = CUDA.adapt(CuArray, theta)\n    height = CUDA.adapt(CuArray, h)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the simulation box (or square to be more precise) is set we compute the first lattice Boltzmann equilibrium Swalbe.equilibrium!(fout, height, velx, vely, vsq). Knowing the initial equilibrium we can enter the lattice Boltzmann time loop. Inside the loop we compute for every time step the forces that are present, here the film pressure (laplacian of the surface and wettability), slippage to regularize the contact line and the pressure gradient","category":"page"},{"location":"","page":"Home","title":"Home","text":"Swalbe.filmpressure!(pressure, height, dgrad, sys.γ, th, sys.n, sys.m, sys.hmin, sys.hcrit)\nSwalbe.∇f!(h∇px, h∇py, pressure, dgrad, height)\nSwalbe.slippage!(slipx, slipy, height, velx, vely, sys.δ, sys.μ)\n# Forces are the pressure gradient and the slippage due to substrate liquid boundary conditions\nFx .= h∇px .+ slipx\nFy .= h∇py .+ slipy","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now that we know the forces we just have to update our distribution functions fout and ftemp (the hot sauce of the lattice Boltzmann method), in this case with a simple single relaxation time collision operator (BGK) and periodic boundary conditions. Last part of the lattice Boltzmann time step is the update of what is called macroscopic quantities (thickness & velocity), or simply the moment calculation (because these are the moments of the distribution mathematically speaking)","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Update the equilibrium\nSwalbe.equilibrium!(feq, height, velx, vely, vsq)\n# Collide and stream\nSwalbe.BGKandStream!(fout, feq, ftemp, -Fx, -Fy)\n# New moments\nSwalbe.moments!(height, velx, vely, fout)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and that's it. Of course to generate data we make snapshots of the film using Swalbe.snapshot!() and return this collection of thicknesses at the end of the simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"What we get is something like this","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Hiern_logo_dewetting)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All of the time steps that were generated during the simulation can be merged together and can be compressed into a movie, see below","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Dewetting_logo)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This example will be further discussed in the Tutorials section.","category":"page"},{"location":"#How-to-**perform-research**","page":"Home","title":"How to perform research","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The numerical approach is quite robust for a lot of thin film simulations.  This means in the limit of small Reynolds and Mach number simulations are usually stable, keeping in mind that for droplet like simulation the contact angle should be on smaller side (θ < π/2).  Things I have looked into so far are","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sliding droplets\nEquilibrium shapes of droplets on patterned substrates, depending on surface tension.\nRayleigh-Taylor instability\nDewetting thin films\nDewetting of fluctuating thin films\nDewetting on switchable substrates","category":"page"},{"location":"","page":"Home","title":"Home","text":"Things I have not yet looked into","category":"page"},{"location":"","page":"Home","title":"Home","text":"Non-Newtonian fluids\nSurfactants\nParticles\nMulticomponent/Multiphase","category":"page"},{"location":"#How-to-**support-and-contribute**","page":"Home","title":"How to support and contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First of all leave a star if you like the idea of the project and/or the content of the package. Second you can support the project by actively using it and raising issues. Help is always very welcome, if you want to contribute open a PR or raise an issue with a feature request (and if possible with a way how to include it). Feel free to DM me on Twitter if you have questions, I try to answer them all timely.","category":"page"}]
}
