<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · Swalbe.jl</title><meta name="title" content="Functions · Swalbe.jl"/><meta property="og:title" content="Functions · Swalbe.jl"/><meta property="twitter:title" content="Functions · Swalbe.jl"/><meta name="description" content="Documentation for Swalbe.jl."/><meta property="og:description" content="Documentation for Swalbe.jl."/><meta property="twitter:description" content="Documentation for Swalbe.jl."/><meta property="og:url" content="https://Ziteronion.github.io/Swalbe.jl/functions/"/><meta property="twitter:url" content="https://Ziteronion.github.io/Swalbe.jl/functions/"/><link rel="canonical" href="https://Ziteronion.github.io/Swalbe.jl/functions/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Swalbe.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li class="is-active"><a class="tocitem" href>Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Zitzeronion/Swalbe.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.equilibrium!-NTuple{4, Any}" href="#Swalbe.equilibrium!-NTuple{4, Any}"><code>Swalbe.equilibrium!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equilibrium!(feq, height, velocity, gravity)</code></pre><p>Calculation of the equilibrium distribution <code>feq</code> for the shallow water lattice Boltzmann method.</p><p><strong>Arguments</strong></p><ul><li><code>feq :: Array{&lt;:Number,3}</code>: Equilibrium distribution function, to be calculated</li><li><code>height :: Array{&lt;:Number,2}</code>: The height field <span>$h(\mathbf{x},t)$</span></li><li><code>velocity :: Array{&lt;:Number,2}</code>: x-component of the macroscopic velocity</li><li><code>gravity &lt;: Number</code>: Strength of the gravitational acceleration in lattice units</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; feq = zeros(10,3); ρ = ones(10); u = fill(0.1,10);

julia&gt; Swalbe.equilibrium!(feq, ρ, u, 0.1) # Supply dummy u^2 as well.

julia&gt; feq[:,1]
10-element Vector{Float64}:
 0.94
 0.94
 0.94
 0.94
 0.94
 0.94
 0.94
 0.94
 0.94
 0.94

julia&gt; @test all(feq[:,1] .≈ 1 - 0.1/2 - 0.01)
Test Passed</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.equilibrium!-NTuple{6, Any}" href="#Swalbe.equilibrium!-NTuple{6, Any}"><code>Swalbe.equilibrium!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equilibrium!(feq, height,velocityx, velocityy, vsquare, gravity)</code></pre><p>Calculation of the equilibrium distribution <code>feq</code> for the shallow water lattice Boltzmann method.</p><p><strong>Arguments</strong></p><ul><li><code>feq :: Array{&lt;:Number,3}</code>: Equilibrium distribution function, to be calculated</li><li><code>height :: Array{&lt;:Number,2}</code>: The height field <span>$h(\mathbf{x},t)$</span></li><li><code>velocityx :: Array{&lt;:Number,2}</code>: x-component of the macroscopic velocity</li><li><code>velocityy :: Array{&lt;:Number,2}</code>: y-component of the macroscopic velocity</li><li><code>vsquare :: Array{&lt;:Number,2}</code>: Dummy array that is preallocated to be filled with the square of the velocity vector</li><li><code>gravity &lt;: Number</code>: Strength of the gravitational acceleration in lattice units</li></ul><p><strong>Mathematics</strong></p><p>The detailed motivation and derivation can be found in the article of Salmon. Similar to the standard Navier-Stokes approximating lattice Boltzmann methods the equilibrium distribution <code>feq</code> is an expansion to second order in velocity <code>u</code>. If you want it is an slow mode part of the shallow water theory and thus the equilibrium is given as</p><p><span>$f_i^{\text{eq}} = h \bigg(1 - \frac{5}{6}g h - \frac{2}{3}u^2\bigg),\quad i=0 \newline    f_i^{\text{eq}} = w_i h \bigg(g h + 3 \mathbf{c}_i\cdot\mathbf{u} + \frac{9}{2}(\mathbf{c}_i\cdot\mathbf{u})^2) + \frac{3}{2}u^2\bigg),\quad else$</span></p><p>where <span>$g$</span> is the gravitational acceleration (in lattice units) and <span>$w_i, \mathbf{c}_i$</span> are the weights and lattice velocities.</p><p>It has been shown that it is possible to get rid of the gravity driven term in the equilibrium distribution, thus</p><p><span>$f_i^{\text{eq}} = h \bigg(1 - \frac{2}{3}u^2\bigg),\quad i=0 \newline f_i^{\text{eq}} = w_i h \bigg(3 \mathbf{c}_i\cdot\mathbf{u} + \frac{9}{2}(\mathbf{c}_i\cdot\mathbf{u})^2) + \frac{3}{2}u^2\bigg),\quad else$</span></p><p>then of course the topography gradient has to be included as a force term.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; feq = zeros(5,5,9); ρ = ones(5,5); ux = fill(0.1,5,5); uy = zeros(5,5);

julia&gt; Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5), 0.1) # Supply dummy u^2 as well.

julia&gt; feq[:,:,1]
5×5 Matrix{Float64}:
 0.91  0.91  0.91  0.91  0.91
 0.91  0.91  0.91  0.91  0.91
 0.91  0.91  0.91  0.91  0.91
 0.91  0.91  0.91  0.91  0.91
 0.91  0.91  0.91  0.91  0.91

julia&gt; Swalbe.equilibrium!(feq, ρ, ux, uy, zeros(5,5), 0.0) # Supply dummy u^2 as well.

julia&gt; @test all(feq[:,:,1] .≈ 1 - 2/3 * 0.01)
Test Passed</code></pre><p><strong>References</strong></p><ul><li><a href="https://www.ingentaconnect.com/contentone/jmr/jmr/1999/00000057/00000003/art00005#">Salmon</a></li><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.65.036309">Dellar</a></li><li><a href="https://onlinelibrary.wiley.com/doi/full/10.1002/fld.4726">Peng et al.</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.BGKandStream!-NTuple{6, Any}" href="#Swalbe.BGKandStream!-NTuple{6, Any}"><code>Swalbe.BGKandStream!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BGKandStream!(fout, feq, ftemp, Fx, Fy, τ)</code></pre><p>Performs a BGK collision operation with a WFM forcecorrection and a subsequent streaming of the resulting populations.</p><p><strong>Arguments</strong></p><ul><li><code>fout :: Array{&lt;:Number,3}</code>: Streamed distribution after the collision processes</li><li><code>feq :: Array{&lt;:Number,3}</code>: Equilibrium distribution, computed with equilibrium!</li><li><code>ftemp :: Array{&lt;:Number,3}</code>: Temporary distribution from the time step before, only useful if <span>$\tau \neq 1$</span></li><li><code>Fx :: Array{&lt;:Number,2}</code>: Sum of forces acting on the fluid in x-direction</li><li><code>Fy :: Array{&lt;:Number,2}</code>: Sum of forces acting on the fluid in y-direction</li><li><code>τ &lt;: Number</code>: Relaxtion time, if not supplied <span>$\tau = 1$</span> assumed</li></ul><p><strong>Mathematics</strong></p><p>The lattice Boltzmann equation in its discretized format is relatively simple to write down</p><p><span>$f_{\alpha}(\mathbf{x}+\mathbf{e}_{\alpha}\Delta t, t+\Delta t) - f_{\alpha}(\mathbf{x}, t) = -\frac{1}{\tau}(f_{\alpha}(\mathbf{x}, t) - f^{\text{eq}}_{\alpha}(\mathbf{x}, t)) + \Delta t \mathcal{S}_{\alpha},$</span></p><p>where the collision kernel is approximated with a BKG single relaxation time (SRT) </p><p><span>$\Omega_{\alpha} = \frac{1}{\tau}(f_{\alpha}(\mathbf{x}, t) - f^{\text{eq}}_{\alpha}(\mathbf{x}, t),$</span></p><p>and a source term <span>$\mathcal{S}$</span> which is given by</p><p><span>$\mathcal{S}_{\alpha} = \frac{3 w_{\alpha}}{e_{\alpha x}e_{\alpha x}+e_{\alpha y}e_{\alpha y}}\mathbf{e_{\alpha}}\cdot\mathbf{F}_{\alpha} .$</span></p><p>The term <span>$e_{\alpha x}e_{\alpha x}+e_{\alpha y}e_{\alpha y}$</span> is either zero for the zeroth population, 1 for the first four populations or 2 for the remaining ones.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe

julia&gt; feq = ones(5,5,9); ftemp = zeros(5,5,9); fout = zeros(5,5,9);

julia&gt; feq[1,1,:] .= 2.0 # To check the streaming process 
9-element view(::Array{Float64, 3}, 1, 1, :) with eltype Float64:
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0

julia&gt; Swalbe.BGKandStream!(fout, feq, ftemp, zeros(5,5), zeros(5,5), 1.0)

julia&gt; fout[:,:,6] # The value 2 should have moved one down and one to the right!
5×5 Matrix{Float64}:
 1.0  1.0  1.0  1.0  1.0
 1.0  2.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
</code></pre><p><strong>References</strong></p><ul><li><a href="https://www.ingentaconnect.com/contentone/jmr/jmr/1999/00000057/00000003/art00005#">Salmon</a></li><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.65.036309">Dellar</a></li><li><a href="https://onlinelibrary.wiley.com/doi/full/10.1002/fld.4726">Peng et al.</a></li></ul><p>See also: <a href="#Swalbe.equilibrium!-NTuple{4, Any}"><code>Swalbe.equilibrium!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.BGKandStream!-Tuple{Any, Any, Any, Vector, Any}" href="#Swalbe.BGKandStream!-Tuple{Any, Any, Any, Vector, Any}"><code>Swalbe.BGKandStream!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BGKandStream!(fout, feq, ftemp, F::Vector, τ)</code></pre><p>Performs a BGK collision operation with a WFM forcecorrection and a subsequent streaming of the resulting populations.</p><p><strong>Arguments</strong></p><ul><li><code>fout :: Array{&lt;:Number,3}</code>: Streamed distribution after the collision processes</li><li><code>feq :: Array{&lt;:Number,3}</code>: Equilibrium distribution, computed with equilibrium!</li><li><code>ftemp :: Array{&lt;:Number,3}</code>: Temporary distribution from the time step before, only useful if <span>$\tau \neq 1$</span></li><li><code>F :: Vector{&lt;:Number,2}</code>: Sum of forces acting on the fluid</li><li><code>τ &lt;: Number</code>: Relaxtion time, if not supplied <span>$\tau = 1$</span> assumed</li></ul><p>See also: <a href="#Swalbe.equilibrium!-NTuple{4, Any}"><code>Swalbe.equilibrium!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.BGKandStream!-Tuple{Swalbe.LBM_state_2D, Swalbe.SysConst}" href="#Swalbe.BGKandStream!-Tuple{Swalbe.LBM_state_2D, Swalbe.SysConst}"><code>Swalbe.BGKandStream!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BGKandStream!(state, sys; τ=sys.param.τ)</code></pre><p>Performs a BGK collision operation with a WFM forcecorrection and a subsequent streaming of the resulting populations.</p><p><strong>Arguments</strong></p><ul><li><code>state &lt;: LBM_state</code>: <code>State</code> data structure, works for every state related data structure</li><li><code>sys :: SysConst</code>: <code>SysConst</code> data structure with τ as parameter</li><li><code>τ :: Float64</code>: relaxation time, default τ=sys.param.τ</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe

julia&gt; sys = Swalbe.SysConst{Float64}(Lx=5, Ly=5, param=Swalbe.Taumucs()); state = Swalbe.Sys(sys, &quot;CPU&quot;);

julia&gt; state.feq[1,1,:] .= 2.0 # To check the streaming process 
9-element view(::Array{Float64, 3}, 1, 1, :) with eltype Float64:
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0
 2.0

julia&gt; Swalbe.BGKandStream!(state, sys)

julia&gt; state.fout[:,:,6] # The value 2 should have moved one down and one to the right!
5×5 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
</code></pre><p>See also: <a href="#Swalbe.equilibrium!-NTuple{4, Any}"><code>Swalbe.equilibrium!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.viewdists-Tuple{Any}" href="#Swalbe.viewdists-Tuple{Any}"><code>Swalbe.viewdists</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">viewdists(f)</code></pre><p>Generates a view for all nine populations of a <strong>D2Q9</strong> distribution function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; ftest = reshape(collect(1.0:225.0),5,5,9);

julia&gt; f0, f1, f2, f3, f4, f5, f6, f7, f8 = Swalbe.viewdists(ftest);

julia&gt; @test all(f3 .== ftest[:,:,4])
Test Passed</code></pre><p>See also: <a href="#Swalbe.BGKandStream!-NTuple{6, Any}"><code>Swalbe.BGKandStream!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.viewdists_1D-Tuple{Any}" href="#Swalbe.viewdists_1D-Tuple{Any}"><code>Swalbe.viewdists_1D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">viewdists_1D(f)</code></pre><p>Generates a view for all three populations of a <strong>D1Q3</strong> distribution function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; ftest = reshape(collect(1.0:30.0),10,3);

julia&gt; f0, f1, f2 = Swalbe.viewdists_1D(ftest);

julia&gt; @test all(f1 .== ftest[:,2])
Test Passed</code></pre><p>See also: <a href="#Swalbe.BGKandStream!-NTuple{6, Any}"><code>Swalbe.BGKandStream!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.moments!-NTuple{4, Any}" href="#Swalbe.moments!-NTuple{4, Any}"><code>Swalbe.moments!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moments!(height, velx, vely, fout)</code></pre><p>Computation of the hydrodynamic moments, <code>height</code> and <code>velocity</code>.</p><p><strong>Mathematics</strong></p><p>The macroscopic quantities such as the height and the velocity are the moments of the distribution function, </p><p><span>$h(\mathbf{x},t) = \sum_{i=0}^8 f_i ,$</span></p><p>and </p><p><span>$\mathbf{v}(\mathbf{x},t) = \frac{1}{h}\sum_{i=0}^8 \mathbf{c}_i f_i .$</span></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; fout = zeros(5,5,9); fout[:,:,1] .= 1.0; fout[:,:,2] .= 0.1; # Dist with artifical velocity in x

julia&gt; height = zeros(5,5); velx = zeros(5,5); vely = zeros(5,5);

julia&gt; Swalbe.moments!(height,velx,vely,fout)

julia&gt; @test all(height .== 1.1)
Test Passed

julia&gt; @test all(velx .== 0.1/1.1)
Test Passed

julia&gt; @test all(vely .== 0.0)
Test Passed</code></pre><p><strong>References</strong></p><ul><li><a href="https://www.springer.com/gp/book/9783319446479">Krüger</a></li><li><a href="https://www.ingentaconnect.com/contentone/jmr/jmr/1999/00000057/00000003/art00005#">Salmon</a></li><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.100.033313">Zitz, Scagliarini and Harting</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.h∇p!-Tuple{Swalbe.LBM_state_2D}" href="#Swalbe.h∇p!-Tuple{Swalbe.LBM_state_2D}"><code>Swalbe.h∇p!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">h∇p!(state)</code></pre><p>Computation of the pressure gradient multiplied with the height.</p><p><strong>Mathematics</strong></p><p>The pressure gradient (<span>$\nabla p$</span>) is <strong>the</strong> driving force of the standard thin film equation <span>$\partial_t h = (M(h)\nabla p)$</span>. Our approach however does not solve the thin film equation directly, Instead we have to add the pressure gradient as a force which is given as</p><p><span>$F_{film} = -\frac{1}{\rho_0} h \nabla p_{film},$</span></p><p>where the term <span>$p_{film}$</span> describes the film pressure </p><p><span>$p_{film} = -\gamma [\Delta h - \Pi(h)] .$</span></p><p>As such it is the combination of a laplacian term that minimizes the surface area as well as a interfacial potential between substrate and fluid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; state = Swalbe.Sys(Swalbe.SysConst(Lx=10, Ly=10, param=Swalbe.Taumucs()), &quot;CPU&quot;);

julia&gt; state.pressure .= reshape(collect(1:100),10,10);

julia&gt; Swalbe.h∇p!(state)

julia&gt; @test all(state.h∇px[1,:] .== -4.0) # at boundary
Test Passed

julia&gt; @test all(state.h∇px[2,:] .== 1.0) # inside
Test Passed</code></pre><p><strong>References</strong></p><ul><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.100.033313">Zitz, Scagliarini and Harting</a></li><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.81.1131">Craster, Matar</a></li><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.69.931">Oron, Davis and Bankoff</a></li></ul><p>See also: <a href="#Swalbe.filmpressure!-NTuple{9, Any}"><code>Swalbe.filmpressure!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.inclination!-Tuple{Vector, Swalbe.LBM_state_2D}" href="#Swalbe.inclination!-Tuple{Vector, Swalbe.LBM_state_2D}"><code>Swalbe.inclination!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>inclination!(α, state)</p><p>Force that mimics the effect of an inclined plate.</p><p>Simple model to add a body force on the fluid that should mimic the effect of an inclined plate. The model includes a smoothing <code>tanh</code> function to absorb shocks which might occure.</p><p><strong>Arguments</strong></p><p>-<code>α :: Vector</code>: Force vector that both hosts direction of the force as well as strength -<code>state::State</code>: Lattice Boltzmann state of the fluid, here we need the <code>state.Fx</code>, <code>state.Fy</code> fields -<code>t::Int</code>: Time step, used for the smoothing <code>tanh</code> factor -<code>tstart::Int</code>: Time delay at which the <code>tanh</code> becomes positve -<code>tsmooth::Int</code>: Time interval over which the <code>tanh</code> is smeared</p><p><strong>Mathematics</strong></p><p>This body force is simply force strength time the mass of the fluid or even simpler the height (assuming ρ=1). Thus the force becomes</p><p><span>$\mathbf{F} = \mathbf{\alpha} h \tanh\bigg(\frac{t-t_0}{t_s}\bigg),$</span></p><p>with <span>$t_0$</span> being the time lag at which the <code>tanh</code> changes sign and <span>$t_s$</span> is width of interval between -1 and 1.</p><p>See also: <a href="#Swalbe.run_dropletforced-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_dropletforced</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.slippage!-NTuple{7, Any}" href="#Swalbe.slippage!-NTuple{7, Any}"><code>Swalbe.slippage!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">slippage!(slipx, slipy, height, velx, vely, δ, μ)</code></pre><p>Fluid substrate interaction that effectively mimics a velocity boundary condition at <span>$h=0$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>slipx :: Array{&lt;:Number,2}</code>: The x-component of the force due the velocity boundary condition</li><li><code>slipy :: Array{&lt;:Number,2}</code>: The y-component of the force due the velocity boundary condition</li><li><code>height::Array{&lt;:Number,2}</code>: Height field <span>$h(\mathbf{x},t)$</span></li><li><code>velx::Array{&lt;:Number,2}</code>: x-component of the macroscopic velocity vector</li><li><code>vely::Array{&lt;:Number,2}</code>: y-component of the macroscopic velocity vector</li><li><code>δ &lt;: Number</code>: Extrapolation length into the substrate where the <strong>no-slip</strong> is met</li><li><code>μ &lt;: Number</code>: Kinematic viscosity of the simulation, dependent on the value of <strong>τ</strong></li></ul><p><strong>Mathematics</strong></p><p>With the velocity boundary condition at the fluid substrate interface we build the second main descriptor between our model and the thin film equation. One well studied assumption is that the fluid velocity vanishes at <span>$h(\mathbf{x}) = 0$</span> which is called <strong>no-slip</strong> condition. In terms of thin film mobility <code>M(h)</code> this means </p><p><span>$M(h) = \frac{h^3}{3\mu}.$</span></p><p>This assumption, however, can be relaxed to allow for some slippage with a further parameter δ which determines the slip length. The here presented model matches the thin film equation by modification of the momentum equation of the shallow water model. Therefore the force we add to the momentum equation to compensate for the substrate fluid friction is given as</p><p><span>$F_{fric} = -\nu \alpha_{\delta}(h)\mathbf{u},$</span></p><p>where ν is the kinematic viscosity and α </p><p><span>$\alpha_{\delta}(h) = \frac{6h}{2h^2 + 6h\delta +3\delta^2},$</span></p><p>and δ being the slip length, or the distance inside the substrate where the fluids velocity vanishes.</p><p><strong>References</strong></p><ul><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.100.033313">Zitz, Scagliarini and Harting</a></li><li><a href="https://link.springer.com/article/10.1007/s10665-005-9020-3">Münch, Wagner und Witelski</a></li><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.69.931">Oron, Davis and Bankoff</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.slippage_ring_riv!-NTuple{8, Any}" href="#Swalbe.slippage_ring_riv!-NTuple{8, Any}"><code>Swalbe.slippage_ring_riv!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">slippage_ring_riv!(slipx, slipy, height, velx, vely, δ, μ)</code></pre><p>Minor modification that disregards the δ square term in the force calculation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.thermal!-NTuple{6, Any}" href="#Swalbe.thermal!-NTuple{6, Any}"><code>Swalbe.thermal!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thermal!(fx, fy, height, kᵦT, μ, δ)</code></pre><p>Computations of force due to thermal fluctuations.</p><p><strong>Arguments</strong></p><ul><li><code>fx :: Array{&lt;:Number,2}</code>: x-component of the force due to the fluctuations</li><li><code>fy :: Array{&lt;:Number,2}</code>: y-component of the force due to the fluctuations</li><li><code>height :: Array{&lt;:Number,2}</code>: Height field <span>$h(\mathbf{x},t)$</span></li><li><code>kᵦT &lt;: Number</code>: Strenght of thermal fluctuations in lattice units</li><li><code>μ &lt;: Number</code>: The kinetic viscosity</li><li><code>δ &lt;: Number</code>: Slip length, needed to normalize</li></ul><p><strong>Mathematics</strong></p><p>The classical thin film equation is an equation without thermal noise which is defined as</p><p><span>$\partial_t h = \nabla\cdot(M(h)\nabla p).$</span></p><p>Classically thermal excitations are neglected for thin film flows. It is of course possible to introduce for example an envolving surface tension or viscosity but both do not account for e.g. the spectrum of thermal capillary waves. The reason for this short coming is the complex from the thin film equation takes if derived from the Landau-Lifshitz Navier-Stokes equation. One addition term due to the stochastic stress tensor makes it somewhat impossible to solve the eqaution self-consistently. However Grün et al. showed that it is not nessary to use the full stochastic stress tensor, but simple a multiplicative noise term</p><p><span>$\partial_t h = \nabla\cdot[M(h)(\nabla p + \sigma \mathcal{N}],$</span></p><p>where <span>$\sigma$</span> and <span>$\mathcal{N}$</span> are a dimensionless temperture and a gaussian white noise. Similar to the pressure gradient the addition of this term is introduced as force in our model</p><p><span>$F_{fluc} = \frac{1}{\rho_0}\sqrt{2k_BT\mu\alpha_{\delta}(h)}\mathcal{N},$</span></p><p>with <span>$\alpha_{\delta}(h)$</span> being the force generated due to substrate slip. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Statistics, Test, Random

julia&gt; Random.seed!(1234); # Set a seed

julia&gt; x = ones(50,50); y = ones(50,50); h = ones(50,50);

julia&gt; Swalbe.thermal!(x, y, h, 0.1, 1/6, 1)

julia&gt; @test mean(x) ≈ 0.0 atol=1e-2
Test Passed

julia&gt; @test mean(y) ≈ 0.0 atol=1e-2
Test Passed

julia&gt; @test var(x) ≈ 2*0.1/11 atol=(2*0.1/11)/10 # var = 2kbt*6*μ/slip
Test Passed</code></pre><p><strong>References</strong></p><ul><li><a href="https://link.springer.com/article/10.1007/s10955-006-9028-8">Grün, Mecke and Rauscher</a></li><li><a href="https://iopscience.iop.org/article/10.1088/0953-8984/17/45/042/meta">Mecke, Rauscher</a></li><li><a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.95.244505">Davidovitch, Moro and Stone</a></li></ul><p>See also: <a href="#Swalbe.slippage!-NTuple{7, Any}"><code>Swalbe.slippage!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.update_rho!-NTuple{5, Any}" href="#Swalbe.update_rho!-NTuple{5, Any}"><code>Swalbe.update_rho!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_rho()</code></pre><p>Time evolution of the <code>active</code> field rho.</p><p>TODO: @Tilman!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.view_four-Tuple{Any}" href="#Swalbe.view_four-Tuple{Any}"><code>Swalbe.view_four</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">view_four()</code></pre><p>Splits a chuck of memory in four equivalent chucks</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.∇γ!-Tuple{T} where T&lt;:Swalbe.Expanded_1D" href="#Swalbe.∇γ!-Tuple{T} where T&lt;:Swalbe.Expanded_1D"><code>Swalbe.∇γ!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_tension_gradient!(state)</code></pre><p>Computes the gradient of a spatially resolved surface tension field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.fast_32-Tuple{Float64}" href="#Swalbe.fast_32-Tuple{Float64}"><code>Swalbe.fast_32</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fast_32(arg)</code></pre><p>Quick computation of a power law potential see <a href="#Swalbe.filmpressure!-NTuple{9, Any}"><code>filmpressure!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.fast_93-Tuple{Float64}" href="#Swalbe.fast_93-Tuple{Float64}"><code>Swalbe.fast_93</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fast_93(arg)</code></pre><p>Quick computation of a power law potential see <a href="#Swalbe.filmpressure!-NTuple{9, Any}"><code>filmpressure!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.filmpressure!-NTuple{9, Any}" href="#Swalbe.filmpressure!-NTuple{9, Any}"><code>Swalbe.filmpressure!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filmpressure!(pressure, height, γ, θ, n, m, hmin, hcrit)</code></pre><p>Calculation of the capillary pressure which is given by <span>$p = - γ∇²h+ Π(h)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>pressure :: Array{Number,2}</code>: Array that store the result of the compuation</li><li><code>height :: Array{Number,2}</code>: Height field <span>$h(\mathbf{x},t)$</span></li><li><code>γ &lt;: Number</code>: Forcing strenght due to surface tension</li><li><code>θ &lt;: Number</code>: Equilibrium contact angle</li><li><code>n :: Int</code>: Larger power law exponent for <span>$Π(h)$</span></li><li><code>m :: Int</code>: Smaller power law exponent for <span>$Π(h)$</span></li><li><code>hmin &lt;: Number</code>: Parameter of <span>$Π(h)$</span>, in fact <span>$Π(hmin) = 0$</span></li><li><code>hcrit &lt;: Number</code>: Numerical stabilizer for case <span>$h(\mathbf{x},t) \ll hmin$</span></li></ul><p><strong>Mathematics</strong></p><p>The capillary pressure <span>$p_{\text{cap}}$</span> is the centeral angle to match our model with the thin film equation. It consists of two parts, first being the laplace pressure <span>$\nabla^2 h$</span> and second being the derivative of the disjoining pontential <span>$\Pi(h)$</span></p><p><span>$p_{\text{cap}} = -\gamma \nabla^2 h + \Pi(h).$</span></p><p>For the laplacian term we use the same nine point discretization as in <code>Swlabe.∇²f!</code>. <span>$\Pi(h)$</span> on the other hand is given by </p><p><span>$\Pi(h) = \kappa(\theta)f(h),$</span></p><p>where <span>$\kappa(\theta)$</span> is simply a measure for the <strong>Hamaker constant</strong> and given as</p><p><span>$\kappa(\theta) = \gamma(1- \cos(\theta))\frac{(n-1)(m-1)}{(n-m)h_{\text{min}}}.$</span></p><p>For <span>$f(h)$</span> one can use various forms, a very common however is the power law given by </p><p><span>$f(h) = \bigg[\bigg(\frac{h_{\text{min}}}{h}\bigg)^n - \bigg(\frac{h_{\text{min}}}{h}\bigg)^m\bigg].$</span></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; h = reshape(collect(1.0:25.0),5,5) # A dummy height field
5×5 Matrix{Float64}:
 1.0   6.0  11.0  16.0  21.0
 2.0   7.0  12.0  17.0  22.0
 3.0   8.0  13.0  18.0  23.0
 4.0   9.0  14.0  19.0  24.0
 5.0  10.0  15.0  20.0  25.0

julia&gt; pressure = zeros(5,5); θ = 0.0; # Fully wetting substrate

julia&gt; Swalbe.filmpressure!(pressure, h, zeros(5,5,8), 0.01, 0.0, 3, 2, 0.1, 0.05) # default γ = 0.01

julia&gt; result = [30.0 5.0 5.0 5.0 -20;
                 25.0 0.0 0.0 0.0 -25.0;
                 25.0 0.0 0.0 0.0 -25.0;
                 25.0 0.0 0.0 0.0 -25.0;
                 20.0 -5.0 -5.0 -5.0 -30.0];

julia&gt; for i in eachindex(result)
           @test result[i] .≈ -100 .* pressure[i] atol=1e-12
       end</code></pre><p><strong>References</strong></p><ul><li><a href="https://www.pnas.org/content/116/19/9275">Peschka et al.</a></li><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.81.1131">Craster and Matar</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/0021979778900565">Derjaguin and Churaev</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.power_2-Tuple{Float64}" href="#Swalbe.power_2-Tuple{Float64}"><code>Swalbe.power_2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">power_2(arg)</code></pre><p>Power two (arg^2) computation of a Float64 number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.power_3-Tuple{Float64}" href="#Swalbe.power_3-Tuple{Float64}"><code>Swalbe.power_3</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">power_3(arg)</code></pre><p>Power three (arg^3) computation of a Float64 number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.power_broad-Tuple{Float64, Int64}" href="#Swalbe.power_broad-Tuple{Float64, Int64}"><code>Swalbe.power_broad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">power_broad(arg, n)</code></pre><p>Computes <code>arg</code> to the power <code>n</code>.</p><p>Actually this is useful because the <code>^</code> operator is much slower. Same thing I learned about the <code>pow</code> function in <strong>C</strong>, * yes it does what you want, but it is slow as fuck *.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; Swalbe.power_broad(3, 3)
27

julia&gt; Swalbe.power_broad.([2.0 5.0 6.0], 2) # Use the broadcasting operator `.`
1×3 Matrix{Float64}:
 4.0  25.0  36.0
</code></pre><p>See also: <a href="#Swalbe.filmpressure!-NTuple{9, Any}"><code>filmpressure!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.viewneighbors-Tuple{Any}" href="#Swalbe.viewneighbors-Tuple{Any}"><code>Swalbe.viewneighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">viewneighbors(f)</code></pre><p>Generates a view for all nine populations of a <strong>D2Q9</strong> distribution function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; ftest = reshape(collect(1.0:5*5*8),5,5,8);

julia&gt; f1, f2, f3, f4, f5, f6, f7, f8 = Swalbe.viewneighbors(ftest);

julia&gt; @test all(f3 .== ftest[:,:,3])
Test Passed</code></pre><p>See also: <a href="#Swalbe.∇f!-Tuple{Any, Any, Any}"><code>Swalbe.∇f!</code></a>, <a href="#Swalbe.filmpressure!-NTuple{9, Any}"><code>Swalbe.filmpressure!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.viewneighbors_1D-Tuple{Any}" href="#Swalbe.viewneighbors_1D-Tuple{Any}"><code>Swalbe.viewneighbors_1D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">viewneighbors_1D(f)</code></pre><p>Generates a view for the two neighbors of a <strong>D1Q3</strong> distribution function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; ftest = reshape(collect(1.0:30),10,3);

julia&gt; f1, f2 = Swalbe.viewneighbors_1D(ftest);

julia&gt; @test all(f2 .== ftest[:,2])
Test Passed</code></pre><p>See also: <a href="#Swalbe.∇f!-Tuple{Any, Any, Any}"><code>Swalbe.∇f!</code></a>, <a href="#Swalbe.filmpressure!-NTuple{9, Any}"><code>Swalbe.filmpressure!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.∇f!-Tuple{Any, Any, Any}" href="#Swalbe.∇f!-Tuple{Any, Any, Any}"><code>Swalbe.∇f!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∇f!(outputx, outputy, f)</code></pre><p>Gradient calculation with finite differences.</p><p>Computes both spatial first derivatives with a nine point stencil from an input <code>f</code> and writes the result to <code>outputx</code> and <code>outputy</code>. Since broadcasting is simple on the <strong>GPU</strong> we make use of <code>circshift</code> for the neighbors.</p><p><strong>Mathematics</strong></p><p>The gardient in two dimensions is given as</p><p><span>$\nabla f = \big(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\big)^T .$</span></p><p>Again with the nine point stencil this reduces to </p><p><span>$\frac{\partial f}{\partial x} = \frac{1}{3} (f_{i+1,j} - f_{i-1,j}) + \frac{1}{12}(f_{i+1,j+1} - f_{i-1,j+1} - f_{i-1,j-1} + f_{i+1,j-1}) ,$</span></p><p>and for the <code>y</code> component we get</p><p><span>$\frac{\partial f}{\partial y} = \frac{1}{3} (f_{i,j+1} - f_{i,j-1}) + \frac{1}{12}(f_{i+1,j+1} + f_{i-1,j+1} - f_{i-1,j-1} - f_{i+1,j-1}) .$</span></p><p>For the exact derivation feel free to read the reference by Junk and Klar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; arg = reshape(collect(1.0:25),5,5)
5×5 Matrix{Float64}:
 1.0   6.0  11.0  16.0  21.0
 2.0   7.0  12.0  17.0  22.0
 3.0   8.0  13.0  18.0  23.0
 4.0   9.0  14.0  19.0  24.0
 5.0  10.0  15.0  20.0  25.0

julia&gt; resx = zeros(5,5); resy = zeros(5,5); Swalbe.∇f!(resx, resy, arg)

julia&gt; whatXshouldbe = [-1.5 -1.5 -1.5 -1.5 -1.5;
                         1.0 1.0 1.0 1.0 1.0;
                         1.0 1.0 1.0 1.0 1.0;
                         1.0 1.0 1.0 1.0 1.0;
                        -1.5 -1.5 -1.5 -1.5 -1.5];

julia&gt; for i in eachindex(resx) # Test the x-component
           @test resx[i] ≈ whatXshouldbe[i] atol=1e-10
       end

julia&gt; whatYshouldbe = [-7.5 5.0 5.0 5.0 -7.5;
                        -7.5 5.0 5.0 5.0 -7.5;
                        -7.5 5.0 5.0 5.0 -7.5;
                        -7.5 5.0 5.0 5.0 -7.5;
                        -7.5 5.0 5.0 5.0 -7.5];

julia&gt; for i in eachindex(resy) # Test the y-component
           @test resy[i] ≈ whatYshouldbe[i] atol=1e-10
       end</code></pre><p><strong>References</strong></p><ul><li><a href="https://epubs.siam.org/doi/10.1137/S1064827599357188">Junk &amp; Klar</a></li><li><a href="https://doi.org/10.1016/j.jcp.2012.07.037">Succi et al.</a></li></ul><p>See also: <a href="#Swalbe.∇²f!-Tuple{Any, Any, Any}"><code>Swalbe.∇²f!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.∇²f!-Tuple{Any, Any, Any}" href="#Swalbe.∇²f!-Tuple{Any, Any, Any}"><code>Swalbe.∇²f!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∇²f!(output, f, γ)</code></pre><p>Finite difference operator for a second derivative in two dimensions.</p><p>Computes the laplacian of an input <code>f</code> times a scalar <code>γ</code> and stores the result in <code>output</code>.</p><p><strong>Mathematics</strong></p><p>The laplacian operator in two dimensions can be written as</p><p><span>$\nabla^2 f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y}.$</span></p><p>For the discretization of this operator we use a nine point stencil, such the neighbors as well as the diagonal elements. The concrete derivation can be found in the references below, we just show the final result</p><p><span>$\nabla^2 f = \frac{1}{6}\bigg[4(f_{i+1,j} + f_{i,j+1} + f_{i-1,j} + f_{i,j-1}) \newline                 \qquad\qquad +(f_{i+1,j+1} + f_{i-1,j+1} + f_{i-1,j-1} + f_{i+1,j-1}) \newline                 \qquad\qquad -20f_{i,j}\bigg]  ,$</span></p><p>where we have used Julia conventions, downwards (left) is positive.  The whole expression can be multiplied with a scalar <code>γ</code> if needed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; arg = reshape(collect(1.0:25),5,5)
5×5 Matrix{Float64}:
 1.0   6.0  11.0  16.0  21.0
 2.0   7.0  12.0  17.0  22.0
 3.0   8.0  13.0  18.0  23.0
 4.0   9.0  14.0  19.0  24.0
 5.0  10.0  15.0  20.0  25.0

julia&gt; res = zeros(5,5); Swalbe.∇²f!(res, arg, -1.0)

julia&gt; analytics = [-30.0 -5.0 -5.0 -5.0 20;
                    -25.0 0.0 0.0 0.0 25.0;
                    -25.0 0.0 0.0 0.0 25.0;
                    -25.0 0.0 0.0 0.0 25.0;
                    -20.0 5.0 5.0 5.0 30.0];

julia&gt; for i in eachindex(analytics)
           @test analytics[i] ≈ res[i] atol=1e-10
       end</code></pre><p><strong>References</strong></p><ul><li><a href="https://epubs.siam.org/doi/10.1137/S1064827599357188">Junk &amp; Klar</a></li><li><a href="https://doi.org/10.1016/j.jcp.2012.07.037">Succi et al.</a></li></ul><p>See also: <a href="#Swalbe.∇f!-Tuple{Any, Any, Any}"><code>Swalbe.∇f!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.CuState" href="#Swalbe.CuState"><code>Swalbe.CuState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuState</code></pre><p><code>State</code> data structure but for CUDA like memory.</p><p>Similar to <code>CuState_thermal</code> without the thermal fields.</p><p><strong>Arguments</strong></p><ul><li><code>fout :: CUDA.CuArray{T,N}</code>: Output distribution function</li><li><code>ftemp :: CUDA.CuArray{T,N}</code>: Temporary distribution function, only used if <code>sys.τ ≠ 1</code></li><li><code>feq :: CUDA.CuArray{T,N}</code>: Equilibrium distribution function</li><li><code>height :: CUDA.CuArray{T}</code>: Field that stores the scalar height values</li><li><code>velx :: CuMatrix{T}</code>: Field that stores the x-component of the velocity vector</li><li><code>vely :: Matrix{T}</code>: Field that stores the y-component of the velocity vector</li><li><code>vsq :: Matrix{T}</code>: Field that stores the velocity squared, used in <code>equilibrium!</code></li><li><code>pressure :: Matrix{T}</code>: Pressure distribution computed using the <code>filmpressure!</code> function</li><li><code>Fx :: Matrix{T}</code>: Total force acting on the fluid, x-component</li><li><code>Fy :: Matrix{T}</code>: Total force acting on the fluid, y-component</li><li><code>slipx :: Matrix{T}</code>: Friction force due to substrate slip, x-component</li><li><code>slipy :: Matrix{T}</code>: Friction force due to substrate slip, y-component</li><li><code>h∇px :: Matrix{T}</code>: Pressure gradient times the height, x-component</li><li><code>h∇py :: Matrix{T}</code>: Pressure gradient times the height, y-component</li><li><code>dgrad :: Array{T,N}</code>: Dummy allocation to store shifted arrays using <code>circshift!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.State" href="#Swalbe.State"><code>Swalbe.State</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">State{T, N}</code></pre><p>Data structure for both macroscopic variables and distribution functions.</p><p><strong>Arguments</strong></p><ul><li><code>fout :: Array{T,N}</code>: Output distribution function</li><li><code>ftemp :: Array{T,N}</code>: Temporary distribution function, only used if <code>sys.τ ≠ 1</code></li><li><code>feq :: Array{T,N}</code>: Equilibrium distribution function</li><li><code>height :: Matrix{T}</code>: Field that stores the scalar height values</li><li><code>velx :: Matrix{T}</code>: Field that stores the x-component of the velocity vector</li><li><code>vely :: Matrix{T}</code>: Field that stores the y-component of the velocity vector</li><li><code>vsq :: Matrix{T}</code>: Field that stores the velocity squared, used in <code>equilibrium!</code></li><li><code>pressure :: Matrix{T}</code>: Pressure distribution computed using the <code>filmpressure!</code> function</li><li><code>Fx :: Matrix{T}</code>: Total force acting on the fluid, x-component</li><li><code>Fy :: Matrix{T}</code>: Total force acting on the fluid, y-component</li><li><code>slipx :: Matrix{T}</code>: Friction force due to substrate slip, x-component</li><li><code>slipy :: Matrix{T}</code>: Friction force due to substrate slip, y-component</li><li><code>h∇px :: Matrix{T}</code>: Pressure gradient times the height, x-component</li><li><code>h∇py :: Matrix{T}</code>: Pressure gradient times the height, y-component</li><li><code>dgrad :: Array{T,N}</code>: Dummy allocation to store shifted arrays using <code>circshift!</code></li></ul><p>See also: <a href="#Swalbe.State_thermal"><code>State_thermal{T, N}</code></a>, <a href="#Swalbe.CuState"><code>CuState</code></a>, <a href="#Swalbe.State_1D"><code>State_1D{T, N}</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.StateWithBound_1D" href="#Swalbe.StateWithBound_1D"><code>Swalbe.StateWithBound_1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StateWithBound_1D{T, N}</code></pre><p>Data structure that stores all arrays for a given simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.State_1D" href="#Swalbe.State_1D"><code>Swalbe.State_1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">State_1D{T, N}</code></pre><p>Data structure that for a one dimensional simulation.</p><p><strong>Arguments</strong></p><ul><li><code>fout :: Matrix{T}</code>: Output distribution function</li><li><code>ftemp :: Matrix{T}</code>: Temporary distribution function, only used if <code>sys.τ ≠ 1</code></li><li><code>feq :: Matrix{T}</code>: Equilibrium distribution function</li><li><code>height :: Vector{T}</code>: Field that stores the scalar height values</li><li><code>vel :: Vector{T}</code>: Field that stores the velocity</li><li><code>pressure :: Vector{T}</code>: Pressure distribution computed using the <code>filmpressure!</code> function</li><li><code>F :: Vector{T}</code>: Total force acting on the fluid</li><li><code>slip :: Vector{T}</code>: Friction force due to substrate slip</li><li><code>h∇p :: Vector{T}</code>: Pressure gradient times the height</li><li><code>dgrad :: Matrix{T}</code>: Dummy allocation to store shifted arrays using <code>circshift!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.State_gamma_1D" href="#Swalbe.State_gamma_1D"><code>Swalbe.State_gamma_1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">State_gamma_1D{T, N}</code></pre><p><code>State_1D</code> data structure with additional fields for surface tension <code>γ</code> and <code>∇γ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>basestate :: State_1D{T}</code>: Base data structure for one dimensional simulations</li><li><code>γ :: Vector{T}</code>: Surface tension field</li><li><code>∇γ :: Vector{T}</code>: Surface tension gardient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.State_thermal" href="#Swalbe.State_thermal"><code>Swalbe.State_thermal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">State_thermal{T, N}</code></pre><p>Data structure that contains a <code>State</code> and fields for thermal fluctuations.</p><p><strong>Arguments</strong></p><ul><li><code>basestate :: State{T,N}</code>: State data structer</li><li><code>kbtx :: Matrix{T}</code>: Force due to thermal fluctuations, x-component</li><li><code>kbty :: Matrix{T}</code>: Force due to thermal fluctuations, y-component</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.State_thermal_1D" href="#Swalbe.State_thermal_1D"><code>Swalbe.State_thermal_1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">State_thermal_1D{T, N}</code></pre><p><code>State_1D</code> data structure with additional fields for thermal fluctuations (noise).</p><p><strong>Arguments</strong></p><ul><li><code>basestate :: State_1D{T}</code>: Base data structure for one dimensional simulations</li><li><code>kbt :: Vector{T}</code>: Surface tension field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.SysConst" href="#Swalbe.SysConst"><code>Swalbe.SysConst</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SysConst{T}</code></pre><p>Struct that contains the system size of a two dimensional system and the struct <code>Taumucs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Lx :: Int</code>: Length of the lattice sides in x-direction</li><li><code>Ly :: Int</code>: Length of the lattice sides in y-direction</li><li><code>s :: Taumucs</code> : Most of the run time constants</li></ul><p>See also: <a href="#Swalbe.SysConst_1D"><code>SysConst_1D{T}</code></a>, <a href="#Swalbe.Taumucs"><code>Taumucs{T}</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.SysConstWithBound_1D" href="#Swalbe.SysConstWithBound_1D"><code>Swalbe.SysConstWithBound_1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SysConstWithBound_1D{T}</code></pre><p>Struct that contains all run time constants, e.g. lattice size, surface tension <code>γ</code> and so on.</p><p><strong>Arguments</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.SysConst_1D" href="#Swalbe.SysConst_1D"><code>Swalbe.SysConst_1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SysConst_1D{T}</code></pre><p>Struct that contains the system size of a one dimensional system and the struct <code>Taumucs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L :: Int</code>: Number of lattice points</li><li><code>s :: Taumucs</code>: Most of the run time constants</li></ul><p>See also: <a href="#Swalbe.SysConst"><code>SysConst{T}</code></a>, <a href="#Swalbe.Taumucs"><code>Taumucs{T}</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.Taumucs" href="#Swalbe.Taumucs"><code>Swalbe.Taumucs</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Taumucs{T}</code></pre><p>Struct that contains most run time constants, e.g. surface tension <code>γ</code>, viscosity <code>μ</code> and so on.</p><p><strong>Arguments</strong></p><ul><li><code>Tmax :: Int</code>: Number of lattice Boltzmann time iterations</li><li><code>tdump :: Int</code>: Dumping interval for e.g. data output</li><li><code>τ :: T</code>: BGK relaxation rate </li><li><code>cₛ :: T</code>: Lattice speed of sound, every physical velocity needs to be smaller than this! </li><li><code>μ :: T</code>: Kinematic fluid viscosity</li><li><code>δ :: T</code>: Slip length, defines how far the <strong>no-slip</strong> condition is interpolated into the substrate</li><li><code>kbt :: T</code>: Thermal energy of the film, works with small values ≈ 10^(-7)</li><li><code>γ :: T</code>: Surface tension</li><li><code>n :: Int</code>: Greater exponent of the two used for the powerlaw in the disjoining pressure</li><li><code>m :: Int</code>: Smaller exponent of the two used for the powerlaw in the disjoining pressure</li><li><code>hmin :: T</code>: Height value at which the disjoining pressure functional vanishes</li><li><code>hcrit :: T</code>: Numerical stabilizer for the disjoining pressure term</li><li><code>θ :: T</code>: Contact angle in multiples of π</li><li><code>g :: T</code>: gravitational acceleration, usually neglected in thin film simulations</li></ul><p>See also: <a href="#Swalbe.SysConst"><code>SysConst{T}</code></a>, <a href="#Swalbe.SysConst_1D"><code>SysConst_1D{T}</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.Sys-Tuple{Swalbe.Consts_1D}" href="#Swalbe.Sys-Tuple{Swalbe.Consts_1D}"><code>Swalbe.Sys</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sys(sysc, T, kind)</code></pre><p>Allocations of arrays used to run a one dimensional simulation.</p><p>Returns a <code>State</code> data structure based on <code>kind</code> the struct can be &quot;simple&quot;, &quot;thermal&quot; or &quot;gamma&quot;.</p><p><strong>Arguments</strong></p><ul><li><code>sysc :: SysConst_1D</code>: Stores the lattice size <code>L</code> </li><li><code>T &lt;: Number</code>: Optional numerical type, default is set to <code>Float64</code></li><li><code>kind :: String</code>: Optional, default is set to <code>simple</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.Sys-Tuple{Swalbe.SysConst, String, Bool, Any}" href="#Swalbe.Sys-Tuple{Swalbe.SysConst, String, Bool, Any}"><code>Swalbe.Sys</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sys(sysc, device, exotic, T)</code></pre><p>Mostly allocations of arrays used to run a simulation, but all within one function :)</p><p>Returns not a data structure such as state, but every array. Therefore it is somewhat outdated by now (2022).</p><p><strong>Arguments</strong></p><ul><li><code>sysc :: SysConst</code>: Needed for the lattice dimensions, <code>Lx</code> and <code>Ly</code></li><li><code>device :: String</code>: Use either <code>CPU</code> for computation of a CPU or <code>GPU</code> for computation on the GPU </li><li><code>exotic :: Bool</code>: If true thermal fluctuations can be computed and saved to the <code>fthermalx</code> and <code>fthermaly</code> field</li><li><code>T &lt;: Number</code>: Numerical type, it is strongly suggested to use <code>Float64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.Sys-Tuple{Swalbe.SysConst, String}" href="#Swalbe.Sys-Tuple{Swalbe.SysConst, String}"><code>Swalbe.Sys</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sys(sysc, device; T, kind)</code></pre><p>Allocations of arrays used to populate the <code>State</code> data structure.</p><p>Returns a <code>State</code> data structure based on <code>sysc</code>, either one dimensional or two dimensional.</p><p><strong>Arguments</strong></p><ul><li><code>sysc :: SysConst</code>: Needed for the lattice dimensions, <code>Lx</code> and <code>Ly</code></li><li><code>device :: String</code>: Use either <code>CPU</code> for computation of a CPU or <code>GPU</code> for computation on the GPU (GPU can only be used with a two dimensional system)</li><li><code>T &lt;: Number</code>: Numerical type, it is strongly suggested to use <code>Float64</code></li><li><code>kind :: String</code>: Indicator for different <code>State</code>&#39;s, default value is &quot;simple&quot; which creates a <code>State</code> data structure, valid options are [&quot;simple&quot;, &quot;thermal&quot;] </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.obslist!-Tuple{Swalbe.SysConstWithBound_1D}" href="#Swalbe.obslist!-Tuple{Swalbe.SysConstWithBound_1D}"><code>Swalbe.obslist!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function obslist1D!(sys::SysConstWithBound; T=Float64, verbose=false)</code></pre><p>Updates interior and border according to obs. See obslist().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.obslist1D-Tuple{Any}" href="#Swalbe.obslist1D-Tuple{Any}"><code>Swalbe.obslist1D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>function obslist1D(obs) Returns a list containing the relevgant obstacle nodes constructed from interior, obsleft, obsright, obsup, obsdown, corneroutlu, corneroutld, corneroutru, corneroutrd, cornerru, cornerrd, cornerlu, cornerld</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.boxpattern-Tuple{Any, Any}" href="#Swalbe.boxpattern-Tuple{Any, Any}"><code>Swalbe.boxpattern</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boxpattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=20)</code></pre><p>Defines a quadratic box around a <code>center</code> with side length <code>side</code>.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Array{undef,2}</code>: Contact angle map</li><li><code>θ₀</code>: Default contact angle <code>θ</code></li><li><code>center::Tuple{Int, Int}</code>: center of the box pattern, default value is <code>(size(θ,1)÷2, size(θ,2)÷2)</code></li><li><code>δₐ::Float64</code>: Contact angle contrast with the substrate, default is set to <code>1/36</code> ≈ 5 degrees difference</li><li><code>side::Int</code>: Length of the sides, default is set to <code>20</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe

julia&gt; θ₀ = 1/9;

julia&gt; pattern, polygon = Swalbe.boxpattern(ones(100,100), θ₀);

julia&gt; polygon # Some cool thing we use to create the posize(θ,2)gones, a LazySet
LazySets.VPolygonModule.VPolygon{Float64, Vector{Float64}}([[40.0, 40.0], [60.0, 40.0], [60.0, 60.0], [40.0, 60.0]])

julia&gt; pattern[50,50] == pattern[1,1] # In the center there is a different contact angle!
false
</code></pre><p><strong>References</strong></p><p>Really not much to say here, check out <a href="https://github.com/JuliaReach/LazySets.jl">LazySets.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.ellipsepattern-Tuple{Any, Any}" href="#Swalbe.ellipsepattern-Tuple{Any, Any}"><code>Swalbe.ellipsepattern</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ellipsepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, a=10, b=5)</code></pre><p>Creates an ellipse shaped contact angle defect with contact angle mismatch <code>δₐ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Array{undef,2}</code>: Contact angle map</li><li><code>θ₀</code>: Default contact angle <code>θ</code></li><li><code>center::Tuple{Int, Int}</code>: center of the created pattern, default values is <code>center = (size(θ,1)÷2, size(θ,2)÷2)</code></li><li><code>δₐ::Float64</code>: contact angle mismatch between patch and rest of substrate, default is <code>δₐ = 1/36</code> or 5 degrees</li><li><code>a::Int</code>:: semimajor half ax of the ellipse, default value is <code>a=10</code></li><li><code>b::Int</code>:: semiminor half ax of the ellipse, default value is <code>b=5</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; θ₀ = 1/9;

julia&gt; θ, P = Swalbe.ellipsepattern(ones(100,100), θ₀); # per default the center is in the middle!

julia&gt; @test θ[1,1] == θ₀
Test Passed

julia&gt; @test θ[50,50] == θ₀ + 1/36 # The default increment, is about 5 degrees.
Test Passed</code></pre><p><strong>References</strong></p><p>Nothing interesting here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.randinterface!-Tuple{Any, Any, Any}" href="#Swalbe.randinterface!-Tuple{Any, Any, Any}"><code>Swalbe.randinterface!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randinterface!(height, h₀, ϵ)</code></pre><p>Creates a random height field with average height <code>h₀</code> and displacement magnitude <code>ϵ</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.restart_from_height-Tuple{Any}" href="#Swalbe.restart_from_height-Tuple{Any}"><code>Swalbe.restart_from_height</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">restart_from_height(data)</code></pre><p>Restarts a simulation from already generated height data.</p><p><strong>Arguments</strong></p><ul><li><code>data::file</code>: Some file with computed data</li><li><code>kind::String</code>: File format, <code>.bson</code> or <code>.jld2</code> are valid options</li><li><code>timestep::Int</code>: The time step the height is read from file</li><li><code>size::Tuple{Int,Int}</code>: x and y limits of the computational domain</li></ul><pre><code class="language-julia hljs">julia&gt; using Swalbe, FileIO, Test

julia&gt; h1 = rand(10,10); h2 = rand(10,10);

julia&gt; f = Dict() # For storage
Dict{Any, Any}()

julia&gt; f[&quot;h_1&quot;] = vec(h1); f[&quot;h_2&quot;] = vec(h2);

julia&gt; save(&quot;file.jld2&quot;, f)

julia&gt; h = Swalbe.restart_from_height(&quot;file.jld2&quot;, timestep=1, size=(10,10));

julia&gt; @test all(h .== h1)
Test Passed

julia&gt; rm(&quot;file.jld2&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.rivulet" href="#Swalbe.rivulet"><code>Swalbe.rivulet</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rivulet(sys; radius, θ, center)</code></pre><p>Generates a rivulet with contact angle <code>θ</code>, sphere radius <code>radius</code> and centered at <code>center</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sys::SysConst{T}</code>: Contains size of the domain</li><li><code>radius::AbstractFloat</code>: radius of the underlying sphere from which the spherical cap is cut</li><li><code>θ::AbstractFloat</code>: contact angle in multiples of <code>π</code></li><li><code>orientation::Symbol</code>: extrusion direction of cap shape</li><li><code>center::Int</code>: coordinate of the center of the cap</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; rad = 45; c = 100; sys = Swalbe.SysConst(Lx=200, Ly=200, param=Swalbe.Taumucs());

julia&gt; height = Swalbe.rivulet(sys, rad, :y, c);

julia&gt; @test maximum(height) == rad * (1 - cospi(sys.param.θ)) # Simple geometry
Test Passed

julia&gt; argmax(height) # Which is constistent with the center!
CartesianIndex(100, 1)
</code></pre><p><strong>References</strong></p><p>See also: <a href="#Swalbe.singledroplet-NTuple{4, Any}"><code>singledroplet</code></a>, <a href="#Swalbe.two_droplets-Tuple{Swalbe.Consts_1D}"><code>two_droplets</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.sinewave1D!-Tuple{Any, Any, Int64, Any, Int64}" href="#Swalbe.sinewave1D!-Tuple{Any, Any, Int64, Any, Int64}"><code>Swalbe.sinewave1D!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sinewave1D!(height, h₀, n, ϵ)</code></pre><p>Creates a sine wave like height field with <code>n</code> full waves, average height <code>h₀</code> and displacement magnitude <code>ϵ</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.singledroplet-NTuple{4, Any}" href="#Swalbe.singledroplet-NTuple{4, Any}"><code>Swalbe.singledroplet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">singledroplet(height, radius, θ, center)</code></pre><p>Generates a fluid configuration of a single droplet in the shape of spherical cap with contact angle <code>θ</code>, sphere radius <code>radius</code> and centered at <code>center</code>.</p><p><strong>Arguments</strong></p><ul><li><code>height::Array{undef, 2}</code>: numerical formate, either <code>Float64</code> or <code>Float32</code></li><li><code>radius::AbstractFloat</code>: radius of the underlying sphere from which the spherical cap is cut off</li><li><code>θ::AbstractFloat</code>: contact angle in multiples of <code>π</code></li><li><code>center::Tuple{Int,Int}</code>: x and y coordinates of the center of the droplet</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; rad = 50; θ = 1/3;

julia&gt; height = Swalbe.singledroplet(ones(100,100), rad, θ, (50,50));

julia&gt; @test maximum(height) == rad * (1 - cospi(θ)) # Simple geometry
Test Passed

julia&gt; argmax(height) # Which is constistent with the center!
CartesianIndex(50, 50)
</code></pre><p><strong>References</strong></p><p>See also: </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.torus" href="#Swalbe.torus"><code>Swalbe.torus</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">torus(lx, ly, r₁, R₂, θ, center, hmin)</code></pre><p>Generates a cut torus with contact angle <code>θ</code>, (<code>x</code>,<code>y</code>) radius <code>R₂</code> and (<code>x</code>,<code>z</code>) radius <code>r₁</code> centered at <code>center</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lx::Int</code>: Size of the domain in x-direction</li><li><code>ly::Int</code>: Size of the domain in y-direction</li><li><code>r₁::AbstractFloat</code>: Radius in (x,z)-plane</li><li><code>R₂::AbstractFloat</code>: Radius in (x,y)-plane</li><li><code>θ::AbstractFloat</code>: contact angle in multiples of <code>π</code></li><li><code>center::Tuple{Int, Int}</code>: Center position of the torus  </li><li><code>hmin::AbstractFloat</code>: small value above 0.0</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; rad = 45; R = 80; θ = 1/9; center = (128, 128);

julia&gt; height = Swalbe.torus(256, 256, rad, R, θ, center);

julia&gt; @test maximum(height) ≈ rad * (1 - cospi(θ)) # Simple geometry
Test Passed

julia&gt; argmax(height) # On the outer ring!
CartesianIndex(128, 48)
</code></pre><p><strong>References</strong></p><p>See also: <a href="#Swalbe.rivulet"><code>rivulet</code></a>, <a href="#Swalbe.singledroplet-NTuple{4, Any}"><code>singledroplet</code></a>, <a href="#Swalbe.two_droplets-Tuple{Swalbe.Consts_1D}"><code>two_droplets</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.trianglepattern-Tuple{Any, Any}" href="#Swalbe.trianglepattern-Tuple{Any, Any}"><code>Swalbe.trianglepattern</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trianglepattern(θ, θ₀; center=(size(θ,1)÷2, size(θ,2)÷2), δₐ=1/36, side=60)</code></pre><p>Generates an equilateral triangle centered around <code>center</code> with contact angle contrast <code>δₐ</code> and side length <code>side</code>.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Array{undef,2}</code>: Contact angle map</li><li><code>θ₀</code>: Default contact angle <code>θ</code></li><li><code>center::Tuple(Int, Int)</code>: position of the center of the triangle</li><li><code>δₐ::Float64</code>: contact angle contrast with the rest of the substrate</li><li><code>side::Int</code>: length of the sides of the equilateral triangle</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe

julia&gt; θ, P = Swalbe.trianglepattern(ones(50,50), 1/9, side=20) # Returns a polygon and the contact angle field
([0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; … ; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111; 0.1111111111111111 0.1111111111111111 … 0.1111111111111111 0.1111111111111111], LazySets.VPolygonModule.VPolygon{Float64, Vector{Float64}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]]))

julia&gt; P
LazySets.VPolygonModule.VPolygon{Float64, Vector{Float64}}([[15.0, 19.226497308103742], [35.0, 19.226497308103742], [25.0, 36.547005383792516]])

julia&gt; θ[25,25]
0.1388888888888889</code></pre><p><strong>References</strong></p><p>See also:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.two_droplets-Tuple{Swalbe.Consts_1D}" href="#Swalbe.two_droplets-Tuple{Swalbe.Consts_1D}"><code>Swalbe.two_droplets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">two_droplets(sys)</code></pre><p>Generates a fluid configuration of a two droplets in the shape of spherical cap with contact angles <code>θ₁</code>, <code>θ₂</code>, sphere radius <code>r₁</code>, <code>r₂</code> and centers at <code>center</code>.</p><p>This is work in progress, therefore so far it is only available for the lower dimension model.</p><p><strong>Arguments</strong></p><ul><li><code>r₁::Float64</code>: radius of the first sphere from which the cap is cut of</li><li><code>r₂::Float64</code>: radius of the second sphere from which the cap is cut of</li><li><code>θ₁::Float64</code>: contact angle of the first cap in multiples of <code>π</code></li><li><code>θ₂::Float64</code>: contact angle of the second cap in multiples of <code>π</code></li><li><code>center::Tuple{Int,Int}</code>: x coordinates of the centers of the droplets</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; rad = 45; θ = 1/4; sys = Swalbe.SysConst_1D(L=200, param=Swalbe.Taumucs());

julia&gt; height = Swalbe.two_droplets(sys, r₁=rad, r₂=rad, θ₁=θ, θ₂=θ);

julia&gt; @test maximum(height) ≈ rad * (1 - cospi(θ)) atol=0.01 # Simple geometry
Test Passed</code></pre><p><strong>References</strong></p><p>See also: </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.fluid_dry!-NTuple{4, Any}" href="#Swalbe.fluid_dry!-NTuple{4, Any}"><code>Swalbe.fluid_dry!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fluid_dry!(fluid, dummy, height, t; hthresh = 0.055)</code></pre><p>Tracks the location of the thin film as a boolean field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.snapshot!-Tuple{Any, Any, Any}" href="#Swalbe.snapshot!-Tuple{Any, Any, Any}"><code>Swalbe.snapshot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">snapshot!(snap, field, t; dumping)</code></pre><p>Makes a copy of the current state of an input array <code>in</code> and saves the vectorized values as a column to <code>out</code>.</p><p>Function that fills a preallocated array out with a time series of system snap shots of e.g. the height field <code>h</code>.</p><p><strong>Arguments</strong></p><ul><li><code>snap :: Array{Number,2}</code>: Array that stores the snap shots as columns</li><li><code>field :: Array{Number,2}</code>: Input argument, e.g. <span>$h(\mathbf{x},t)$</span></li><li><code>t :: Int</code>: The current time step</li><li><code>dumping :: Int</code>: Sampling frequency</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Swalbe, Test

julia&gt; h1 = reshape(collect(1:25),5,5); h2 = reshape(collect(5:5:125),5,5);

julia&gt; snapshot = zeros(2, 25);

julia&gt; Swalbe.snapshot!(snapshot,h1,10,dumping=10)

julia&gt; Swalbe.snapshot!(snapshot,h2,20,dumping=10)

julia&gt; @test all(h1 .== reshape(snapshot[1,:],5,5))
Test Passed
julia&gt; @test all(h2 .== reshape(snapshot[2,:],5,5))
Test Passed</code></pre><p><strong>References</strong></p><p>See also: The <a href="https://github.com/Zitzeronion/Swalbe.jl/tree/master/scripts">scripts folder</a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.surfacearea!-Tuple{Any, Any, Any, Float64, Vararg{Any, 5}}" href="#Swalbe.surfacearea!-Tuple{Any, Any, Any, Float64, Vararg{Any, 5}}"><code>Swalbe.surfacearea!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surfacearea!(area_lv, red_energy, height, θ, ∇hx, ∇hy, dgrad, surface,)</code></pre><p>Measures the surface area of the liquid vapor interface and the reduced surface energy.</p><p><strong>Arguments</strong></p><ul><li><code>area_lv :: Vector{Float64}</code>: array to store the computed liquid vapor area</li><li><code>red_energy :: Vector{Float64}</code>: array the stores the computed reduced surface energy </li><li><code>height :: Matrix{Float64}</code>: current height configuration</li><li><code>θ :: Matrix{Float64}</code>: contact angle field distribution</li><li><code>∇hx :: Matrix{Float64}</code>: height gradient x-component </li><li><code>∇hy :: Matrix{Float64}</code>: height gradient y-component</li><li><code>dgrad :: Array{Float64,3}</code>: dummy array to store derivatives </li><li><code>surface :: Matrix{Float64}</code>: array that computes locally the liquid vapor surface area </li><li><code>t :: Int</code>: current time step</li><li><code>hthresh :: Float64</code>: height threshold below which the substrate is considered <em>dry</em></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.t0-Tuple{}" href="#Swalbe.t0-Tuple{}"><code>Swalbe.t0</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">t0(;hᵦ=0.07, γ=0.01, μ=1/6, θ=1/6)</code></pre><p>Computes a characteristic time scale for an spinodally dewetting film.</p><p><strong>Arguments</strong></p><ul><li><code>hᵦ :: Float64</code>: height at which the disjoining pressure vanishes</li><li><code>γ :: Float64</code>: surface tension value</li><li><code>μ :: Float64</code>: kinematic viscosity, same as dynamic for ρ=1</li><li><code>θ :: Float64</code>: highest contact angle given as radiant, e.g. θ=π/9 for 20 degrees</li></ul><p><strong>Mathematics</strong></p><p>The charateristic time scale <span>$t_0$</span> is set using the surface tension as well as the disjoining pressure <span>$\Pi(h)$</span> as </p><p><span>$t_0 = \frac{3}{\gamma h_0^3 q_0^4}, \quad q_0 = \frac{\Pi&#39;(h_0)}{2\gamma},$</span></p><p>where <span>$\Pi&#39;(h_0) = \frac{\partial\Pi}{\partial h}\bigg|_{h_0}$</span> is the derivative of the disjoining pressure with respect to some characteristic height.</p><p><strong>References</strong></p><ul><li><a href="https://iopscience.iop.org/article/10.1088/0953-8984/17/45/042/meta">Mecke, Rauscher</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.wetted!-NTuple{4, Any}" href="#Swalbe.wetted!-NTuple{4, Any}"><code>Swalbe.wetted!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">wetted!(area_size, drop_pos, maxheight, height, t; hthresh = 0.055)</code></pre><p>Measures the wetted area and maximal height of the film at time step <code>t</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.∇f_simple!-NTuple{4, Any}" href="#Swalbe.∇f_simple!-NTuple{4, Any}"><code>Swalbe.∇f_simple!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∇f_simple!(outputx, outputy, f, dgrad)</code></pre><p>Simple gradient calculation for the differential surface area.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.run_dropletforced-Tuple{Swalbe.SysConst, String}" href="#Swalbe.run_dropletforced-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_dropletforced</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_dropletforced()</code></pre><p>Simulates a sliding droplet</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.run_dropletpatterned-Tuple{Swalbe.SysConst, String}" href="#Swalbe.run_dropletpatterned-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_dropletpatterned</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_dropletpatterned()</code></pre><p>Simulates an droplet on a patterned substrate</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.run_dropletrelax-Tuple{Swalbe.SysConst, String}" href="#Swalbe.run_dropletrelax-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_dropletrelax</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_dropletrelax()</code></pre><p>Simulates an out of equilibrium droplet</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.run_flat-Tuple{Swalbe.SysConst, String}" href="#Swalbe.run_flat-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_flat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_flat(Sys::SysConst, device::String)</code></pre><p>Performs a simulation of an flat interface without forces.</p><p><strong>Arguments</strong></p><ul><li><code>verbos :: Bool</code>: Enables consol output</li><li><code>T :: AbstractFloat</code>: Precision of output, default <code>Float64</code></li></ul><p><strong>Theory</strong></p><p>Nothing at all should happen. As the initial state is falt and no force is applied the fluid has no way to flow. The equality <span>$h(\mathbf{x},0) = h(\mathbf{x},\infty),$</span> should be satisfied for arbitrary many time steps.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using Swalbe, Test

julia&gt; sys = Swalbe.SysConst(Lx=100, Ly=100, Tmax=5000);

julia&gt; h = Swalbe.run_flat(sys, &quot;CPU&quot;, verbos=false);

julia&gt; @test all(h.height .== 1.0) # Check if all height values are identical to 1.0 (initial condition)
Test passed</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.run_gamma-Tuple{Swalbe.SysConst_1D, Vector}" href="#Swalbe.run_gamma-Tuple{Swalbe.SysConst_1D, Vector}"><code>Swalbe.run_gamma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_(sys::Swalbe.SysConst_1D,
	 gamma::Vector;
	 r₁=115,
	 r₂=115, 
	 θ₀=1/9,  
	 verbos=true, 
	 dump = 100, 
	 fluid=zeros(sys.param.Tmax÷dump, sys.L))</code></pre><p>Lattice Boltzmann simulation of coalescing droplets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.run_random-Tuple{Swalbe.SysConst, String}" href="#Swalbe.run_random-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_random</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_random(sys::SysConst, device::String)</code></pre><p>Simulation of an random undulated interface</p><p><strong>Arguments</strong></p><ul><li><code>h₀ :: Float</code> : Average initial height</li><li><code>ϵ :: Float</code> : Amplitude of the flucutation</li><li><code>verbos :: Bool</code>: Enables consol output</li><li><code>T :: AbstractFloat</code>: Precision of output, default <code>Float64</code></li></ul><p><strong>Theory</strong></p><p>Initial randomly perturbed fluid surface. Unstable wavemodes should grow while wavemodes larger q₀ should be damped out. Measuring this is on the TODO list.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using Swalbe, Test

julia&gt; sys = Swalbe.SysConst(Lx=100, Ly=100, Tmax=5000);

julia&gt; Swalbe.randinterface!(height, h₀, ϵ)

julia&gt; h = Swalbe.run_random(sys, &quot;CPU&quot;, h₀=10, ϵ=0.1, verbos=false);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.run_rayleightaylor-Tuple{Swalbe.SysConst, String}" href="#Swalbe.run_rayleightaylor-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_rayleightaylor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_rayleightaylor(sys::SysConst, device::String)</code></pre><p>Simulation of an random undulated interface and a gravitanional pull.</p><p><strong>Arguments</strong></p><ul><li><code>kx :: Int</code> : wavemode in x-direction, kx=18 -&gt; 18 sine waves fitting into the domain</li><li><code>ky :: Int</code> : wavemode in y-direction</li><li><code>h₀ :: Float</code> : Average initial height</li><li><code>ϵ :: Float</code> : Amplitude of the flucutation</li><li><code>verbos :: Bool</code>: Enables consol output</li><li><code>T :: AbstractFloat</code>: Precision of output, default <code>Float64</code></li></ul><p><strong>Theory</strong></p><p>Initial randomly perturbed fluid surface hanging from a substrate. Here we have an interplay between gravity and surface tension. The critical wavemode can be computed according to  <span>$q_0 =$</span> Measuring this is on the TODO list.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using Swalbe, Test

julia&gt; sys = Swalbe.SysConst(Lx=100, Ly=100, Tmax=5000);

julia&gt; Swalbe.randinterface!(height, h₀, ϵ)

julia&gt; h = Swalbe.run_random(sys, &quot;CPU&quot;, h₀=10, ϵ=0.1, verbos=false);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Swalbe.time_loop-Tuple{Swalbe.SysConst, Swalbe.LBM_state_2D}" href="#Swalbe.time_loop-Tuple{Swalbe.SysConst, Swalbe.LBM_state_2D}"><code>Swalbe.time_loop</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_loop(sys, state)</code></pre><p>Time stepping procedure for the lattice Boltzmann state <code>state</code> given parameters <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/Swalbe.jl">source</a></section></article><ul><li><a href="#Swalbe.CuState"><code>Swalbe.CuState</code></a></li><li><a href="#Swalbe.State"><code>Swalbe.State</code></a></li><li><a href="#Swalbe.StateWithBound_1D"><code>Swalbe.StateWithBound_1D</code></a></li><li><a href="#Swalbe.State_1D"><code>Swalbe.State_1D</code></a></li><li><a href="#Swalbe.State_gamma_1D"><code>Swalbe.State_gamma_1D</code></a></li><li><a href="#Swalbe.State_thermal"><code>Swalbe.State_thermal</code></a></li><li><a href="#Swalbe.State_thermal_1D"><code>Swalbe.State_thermal_1D</code></a></li><li><a href="#Swalbe.SysConst"><code>Swalbe.SysConst</code></a></li><li><a href="#Swalbe.SysConstWithBound_1D"><code>Swalbe.SysConstWithBound_1D</code></a></li><li><a href="#Swalbe.SysConst_1D"><code>Swalbe.SysConst_1D</code></a></li><li><a href="#Swalbe.Taumucs"><code>Swalbe.Taumucs</code></a></li><li><a href="#Swalbe.BGKandStream!-Tuple{Any, Any, Any, Vector, Any}"><code>Swalbe.BGKandStream!</code></a></li><li><a href="#Swalbe.BGKandStream!-NTuple{6, Any}"><code>Swalbe.BGKandStream!</code></a></li><li><a href="#Swalbe.BGKandStream!-Tuple{Swalbe.LBM_state_2D, Swalbe.SysConst}"><code>Swalbe.BGKandStream!</code></a></li><li><a href="#Swalbe.Sys-Tuple{Swalbe.Consts_1D}"><code>Swalbe.Sys</code></a></li><li><a href="#Swalbe.Sys-Tuple{Swalbe.SysConst, String, Bool, Any}"><code>Swalbe.Sys</code></a></li><li><a href="#Swalbe.Sys-Tuple{Swalbe.SysConst, String}"><code>Swalbe.Sys</code></a></li><li><a href="#Swalbe.boxpattern-Tuple{Any, Any}"><code>Swalbe.boxpattern</code></a></li><li><a href="#Swalbe.ellipsepattern-Tuple{Any, Any}"><code>Swalbe.ellipsepattern</code></a></li><li><a href="#Swalbe.equilibrium!-NTuple{6, Any}"><code>Swalbe.equilibrium!</code></a></li><li><a href="#Swalbe.equilibrium!-NTuple{4, Any}"><code>Swalbe.equilibrium!</code></a></li><li><a href="#Swalbe.fast_32-Tuple{Float64}"><code>Swalbe.fast_32</code></a></li><li><a href="#Swalbe.fast_93-Tuple{Float64}"><code>Swalbe.fast_93</code></a></li><li><a href="#Swalbe.filmpressure!-NTuple{9, Any}"><code>Swalbe.filmpressure!</code></a></li><li><a href="#Swalbe.fluid_dry!-NTuple{4, Any}"><code>Swalbe.fluid_dry!</code></a></li><li><a href="#Swalbe.h∇p!-Tuple{Swalbe.LBM_state_2D}"><code>Swalbe.h∇p!</code></a></li><li><a href="#Swalbe.inclination!-Tuple{Vector, Swalbe.LBM_state_2D}"><code>Swalbe.inclination!</code></a></li><li><a href="#Swalbe.moments!-NTuple{4, Any}"><code>Swalbe.moments!</code></a></li><li><a href="#Swalbe.obslist!-Tuple{Swalbe.SysConstWithBound_1D}"><code>Swalbe.obslist!</code></a></li><li><a href="#Swalbe.obslist1D-Tuple{Any}"><code>Swalbe.obslist1D</code></a></li><li><a href="#Swalbe.power_2-Tuple{Float64}"><code>Swalbe.power_2</code></a></li><li><a href="#Swalbe.power_3-Tuple{Float64}"><code>Swalbe.power_3</code></a></li><li><a href="#Swalbe.power_broad-Tuple{Float64, Int64}"><code>Swalbe.power_broad</code></a></li><li><a href="#Swalbe.randinterface!-Tuple{Any, Any, Any}"><code>Swalbe.randinterface!</code></a></li><li><a href="#Swalbe.restart_from_height-Tuple{Any}"><code>Swalbe.restart_from_height</code></a></li><li><a href="#Swalbe.rivulet"><code>Swalbe.rivulet</code></a></li><li><a href="#Swalbe.run_dropletforced-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_dropletforced</code></a></li><li><a href="#Swalbe.run_dropletpatterned-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_dropletpatterned</code></a></li><li><a href="#Swalbe.run_dropletrelax-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_dropletrelax</code></a></li><li><a href="#Swalbe.run_flat-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_flat</code></a></li><li><a href="#Swalbe.run_gamma-Tuple{Swalbe.SysConst_1D, Vector}"><code>Swalbe.run_gamma</code></a></li><li><a href="#Swalbe.run_random-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_random</code></a></li><li><a href="#Swalbe.run_rayleightaylor-Tuple{Swalbe.SysConst, String}"><code>Swalbe.run_rayleightaylor</code></a></li><li><a href="#Swalbe.sinewave1D!-Tuple{Any, Any, Int64, Any, Int64}"><code>Swalbe.sinewave1D!</code></a></li><li><a href="#Swalbe.singledroplet-NTuple{4, Any}"><code>Swalbe.singledroplet</code></a></li><li><a href="#Swalbe.slippage!-NTuple{7, Any}"><code>Swalbe.slippage!</code></a></li><li><a href="#Swalbe.slippage_ring_riv!-NTuple{8, Any}"><code>Swalbe.slippage_ring_riv!</code></a></li><li><a href="#Swalbe.snapshot!-Tuple{Any, Any, Any}"><code>Swalbe.snapshot!</code></a></li><li><a href="#Swalbe.surfacearea!-Tuple{Any, Any, Any, Float64, Vararg{Any, 5}}"><code>Swalbe.surfacearea!</code></a></li><li><a href="#Swalbe.t0-Tuple{}"><code>Swalbe.t0</code></a></li><li><a href="#Swalbe.thermal!-NTuple{6, Any}"><code>Swalbe.thermal!</code></a></li><li><a href="#Swalbe.time_loop-Tuple{Swalbe.SysConst, Swalbe.LBM_state_2D}"><code>Swalbe.time_loop</code></a></li><li><a href="#Swalbe.torus"><code>Swalbe.torus</code></a></li><li><a href="#Swalbe.trianglepattern-Tuple{Any, Any}"><code>Swalbe.trianglepattern</code></a></li><li><a href="#Swalbe.two_droplets-Tuple{Swalbe.Consts_1D}"><code>Swalbe.two_droplets</code></a></li><li><a href="#Swalbe.update_rho!-NTuple{5, Any}"><code>Swalbe.update_rho!</code></a></li><li><a href="#Swalbe.view_four-Tuple{Any}"><code>Swalbe.view_four</code></a></li><li><a href="#Swalbe.viewdists-Tuple{Any}"><code>Swalbe.viewdists</code></a></li><li><a href="#Swalbe.viewdists_1D-Tuple{Any}"><code>Swalbe.viewdists_1D</code></a></li><li><a href="#Swalbe.viewneighbors-Tuple{Any}"><code>Swalbe.viewneighbors</code></a></li><li><a href="#Swalbe.viewneighbors_1D-Tuple{Any}"><code>Swalbe.viewneighbors_1D</code></a></li><li><a href="#Swalbe.wetted!-NTuple{4, Any}"><code>Swalbe.wetted!</code></a></li><li><a href="#Swalbe.∇f!-Tuple{Any, Any, Any}"><code>Swalbe.∇f!</code></a></li><li><a href="#Swalbe.∇f_simple!-NTuple{4, Any}"><code>Swalbe.∇f_simple!</code></a></li><li><a href="#Swalbe.∇²f!-Tuple{Any, Any, Any}"><code>Swalbe.∇²f!</code></a></li><li><a href="#Swalbe.∇γ!-Tuple{T} where T&lt;:Swalbe.Expanded_1D"><code>Swalbe.∇γ!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/">« Tutorials</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 1 September 2025 09:19">Monday 1 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
